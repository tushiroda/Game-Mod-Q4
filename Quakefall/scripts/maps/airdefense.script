//------------------------------------------------------------------------------------
// AirDefense.script
//
// (c) Raven Software 2005
//------------------------------------------------------------------------------------

namespace map_airdefense	{

//------------------------------------------------------------------------------------
// Globals

//has morris met kane yet?
float g_morrisMeetsKane = 0;

//is the "need a medic" badger scene ready?
float g_badgerSceneReady = 0;

//trench effect flags
float g_trenchOneEffects = 0;
float g_trenchTwoEffects = 0;

//reinforcements in the intro combat room (second pass)
float g_combatReinforcements = 0;

//this is when the strogg flyer can target Bidwell, Sledge and Morris,
float g_flyerInRange = 0;

// used by anderson when he is in seek-heal mode (ie, a heal has been requested and is in progress)
float g_andersonHealing = 0;

//------------------------------------------------------------------------------------
// Prototypes

//an actual strogg fighter flying along, keeping the marines pinned down.
// entFighter = entity to fly along with
// fValue = playback to start with, 0 < fValue <= fMaxPlaybacks
// fMaxPlaybacks = maximum number of playbacks in sequence
void maintainFighterStrafe(entity entFighter, float fValue, float fMaxPlaybacks);

// drag the hapless marine away
void dragMarine();

// intro sequence where the player gets his orders from the Sargeant
void introWithSarge();

//move the initial wreckage debris out of the way
void moveDebris();

// The blaster pickup- has to be faked because the player always has a blaster with him.
void grabBlaster();

//launches a strogg body into the air and down into the trench
void flingStroggBody();

// intro to jabroni, this is when he wrestles with the grunt
void jabroniWrestle();

//grunt takes a mean shotgun blast here
void gruntBlasted();

//starts the runs of the three trench fighters
void startTrenchCombat();

//pipes burst, grunt spews out, oh it's good times.
void pipeBustin();

//knocks the player back from the grunt's busting pipes
void playerKnockback();

//send the grunt running toward the pipes, but it's all hokum, we'll just teleport him to the
//right spot when it's time to make him smash
void gruntRunToPipes();

//runs an injured marine through pain anims
void injuredMarineLoop(entity marine, entity doctor);

//handle the dead and skewered marine
void skewerMarine();

//open the doors for the skewering berserker
void openSkewerDoors();

//strafe the tunnel in the trench!
void tunnelBomb();

//Walker one, the one that gets hit and all blowed up
void walkerOne();

//This one lives. Yay life.
void walkerTwo();

//Flyer loop, maintains the shooting and aiming of the animated flyer
void flyerTrenchLoop();
void flyerRocketLoop();
void trenchStrafeRun();
void trenchStrafeRun2();

//fires an FX rocket from one point to another
void fireTrenchRocket(string rocketTarget);

//maintains the big gun
void maintainBigGun();

//the conversation in the trench between four NPCs and the player
void trenchConversation(); 

//handles a marine who is guarding the trenches
void marineOnTrenchWall(entity entMarine);

//determines which cool walker firing anim he'll use
void walkerFireManager(entity entDriver);

void kovitchIdle();
void hillstromHelpsWoundMarine();

//maintains the trench rockets: none of them will hit.
void maintainTrenchRockets();

//player picks up the medic
void gotMedic();

//Use this to manage the tracer fire out back
void activateTrenchTracers(float fStart, float fEnd);
void deactivateTrenchTracers(float fStart, float fEnd);

// This will turn on all the effects in trench one (the west one)
void activateTrenchOneEffects();
void deactivateTrenchOneEffects();

void activateTrenchTwoEffects();
void deactivateTrenchTwoEffects();

void maintainSecondTrenchExplosions();
void maintainFirstTrenchExplosions();

//morris' conversations at the introduction
void morrisIntroTalkToPlayer();
void morrisIntroLoop();
void _morrisIntroLoop();

//adds the first NPC marine to the Kane
//void prepareIntroParty();

//plays an ambient sound speaker with a tied in VO speaker
//void playAmbientWithVO( float speakerID, float waitTime);
//void playAmbient_1();
//void playAmbient_2();
//void playAmbient_3();
//void playAmbient_4();
//void playAmbient_5();

//battles indoor with the strogg marines by AI marines
//void _indoorBattle1();
//void _indoorBattle2();

//simple AI for the medic
void medicHealingCheck(entity entMedic);
void medicHealPlayer(entity entMedic);

//sgt bidwell waves the player over.
void bidwellCallPlayer();

//When the flyer that roves around the 2nd trench is in range, certain things happen.
void trenchFlyerInRange();
void trenchFlyerOutRange();

//keeps the marines down when under fire
void marineCowerLoop( entity entMarine, string strAnim );

//harvester intro 
void vistaHarvesterOne();
void vistaHarvesterTwo();

//this lets the walker fire from various joints, it's all a dirty terrible hack.
void walkerFireFromJoint( float fJoint, entity entWeapon);

//This is the core of the Condor Squad scene.
void millerHelpsWoundedMarine();

//underwood rolls into the trench
void underwoodRoll();

//------------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------------

void andersonDragsMedic()
{
	aiScriptedAnimLoop( $marine_anderson_standin, "kneel_loop_1b", 4);
	aiScriptedAnimLoop( $char_marine_wounded_medic, "lay_loop_1a", 4);

	sys.wait(3);

	aiScriptedAnim( $marine_anderson_standin, "liftlegs_b", 4, 0);
	aiScriptedAnimWait( $char_marine_wounded_medic, "liftlegs_a", 4, 0);

	aiScriptedAnimLoop( $marine_anderson_standin, "drag_loop_b", 4);
	aiScriptedAnimLoop( $char_marine_wounded_medic, "drag_loop_a", 4);

	sys.wait(4.5);

//	aiScriptedAnim( $marine_anderson_standin, "setdown_b", 4, 0);
//	aiScriptedAnimWait( $char_marine_wounded_medic, "setdown_a", 4, 0);

//	aiScriptedAnimLoop( $marine_anderson_standin, "kneel_loop_2b", 4);
//	aiScriptedAnimLoop( $char_marine_wounded_medic, "lay_loop_2a", 4);

	$marine_anderson_standin.remove();
	$char_marine_wounded_medic.remove();
}

//------------------------------------------------------------------------------------
void webbSummonsPlayer()
{
	// switch anim_idle...now use, anim_first_idle as our idle
	$npc_redshirt_1.setPassivePrefix("action");
	$npc_redshirt_1.setAnimRate(1.3);
	aiScriptedAnim( $npc_redshirt_1, "ad_door_marine", 8, 1 );
	sys.wait(3.5);
	aiSpeak( $npc_redshirt_1, "lipsync_1_1_1_43_1" );
	$npc_redshirt_1.lookAt( $player1 );
	while (! aiScriptedDone( $npc_redshirt_1 ))
	{
		sys.waitFrame();
	}
	$npc_redshirt_1.setAnimRate(1);
}

//------------------------------------------------------------------------------------
void webbJoinsPlayer()
{
	$npc_redshirt_1.lookAt( $null_entity );
	$npc_redshirt_1.setLeader( $player1 );
	$npc_redshirt_1.becomeAggressive();
}

//------------------------------------------------------------------------------------
void webbTakeCover()
{
	$npc_redshirt_1.setLeader( $null_entity );
}

//------------------------------------------------------------------------------------
// drag the hapless marine away
//------------------------------------------------------------------------------------
void dragMarine()	
{
	sys.trigger( $spkr_grunt_drag_music);

	aiScriptedAnim( $marine_grunt_drag, "ad_marine_dragged", 4, 0);
	aiScriptedAnimWait( $mon_grunt_drag, "ad_grunt_drags", 4, 0);

	$grunt_door_2.close();
	
	while ( $grunt_door_2.isOpen())
	{
		sys.waitFrame();
	}

	// remove them
	$mon_grunt_drag.remove();
	$marine_grunt_drag.remove();
	
	// disarm the marine
//	sys.println( "Arm collapsed");
//	$env_ragdoll_marine_fullgear_1.collapseJoints( "*r_elbo", "r_up_arm");
//	$env_ragdoll_marine_fullgear_1.collapseJoints( "*r_up_arm", "r_clavicle");
//	sys.waitFrame();
//	sys.trigger( $env_ragdoll_marine_fullgear_1);
//	sys.wait(2);	
}

// TODO:  previously called from closeDragDoor()
// sys.wait(1);
// thread playAmbientWithVO(5, 3);

//------------------------------------------------------------------------------------
// unlock the door just before the drag grunt
//------------------------------------------------------------------------------------
void unlockPreDragDoor()
{
	$preGruntDoor_1.lock(0);
	$preGruntDoor_2.lock(0);
}


// intro sequence where the player gets his orders from the Sargeant
void introWithSarge()	{

	//TODO: lots of VO and jive here needed. But we don't have it ready yet.
	aiScriptedAnim( $npc_sarge, "point_right", 4, 1);
	
	//objectives
	sys.trigger( $objectiveIntro);
	sys.wait(4);
	sys.trigger( $objectiveWeaponGet);

	//move the door guard out of the way
	aiScriptedAnimWait( $marine_door_intro, "point_back", 4, 1);
	$stc_intro_block.remove();
	aiScriptedMoveWait( $marine_door_intro, $tgt_marine_door_intro, 1, 1);
	aiScriptedFace( $marine_door_intro, $player1, 1);
	

}

//move the initial wreckage debris out of the way
void moveDebris()	{

	$player1.setWorldOrigin( $tgt_player_intro_1.getWorldOrigin());
	$player1.bind( $mov_intro);

	sys.fadeIn( '0 0 0', 5);
	sys.wait(5);

	//animate
	aiScriptedAnim( $npc_debris, "remove_debris", 4, 1);
	
	sys.wait(1);

	//move!
	$mov_debris_1.time(3);
	$mov_debris_1.accelTime(3);
	$mov_debris_1.moveTo( $tgt_debris_move);
	sys.waitFor($mov_debris_1);
	
	//change from mover to physics object
	$mvb_debris.unbind();
	sys.waitFrame();
	$mov_debris_1.bind( $mvb_debris);
	sys.waitFrame();
	$mvb_debris.applyImpulse( $mvb_debris, $mvb_debris.getWorldOrigin(), '0 0 -2000');

	sys.wait(1.5);

	//accelerate the whole time	
	$mov_intro.time(2.4);
	$mov_intro.accelTime(2.4);

	//lift the player up
	$mov_intro.moveTo( $tgt_player_intro_2);
	
	//set him down
	sys.waitFor( $mov_intro);
	$player1.unbind();
	$mov_intro.remove();


}

// The blaster pickup- has to be faked because the player always has a blaster with him.
// EDIT: It's a machine gun now.
void grabBlaster()	{

	sys.println("grabBlaster::begin");
	//strogg jump-- like gymkata but not as cool
	aiScriptedAnim( $strogg_jump, "jump_trench", 4, 1);
	sys.wait(2);
	aiScriptedAnim( $strogg_jump_2, "jump_trench", 4, 1);


}

//launches a strogg body into the air and down into the trench
void flingStroggBody()	{
	
	//spawn a strogg marine at that point
	entity entStrogg = $mon_strogg_trench; //sys.spawn("monster_strogg_marine");
	entStrogg.setWorldOrigin( $tgt_strogg_trench_launch.getWorldOrigin() );
	sys.trigger( entStrogg);
	sys.waitFrame();

	//set off the foom and kill the strogg
	sys.trigger( $fx_strogg_trench_explosion);
	entStrogg.kill();
	sys.waitFrame();

	//fling!
	entStrogg.applyImpulse( entStrogg, entStrogg.getWorldOrigin(), '0 -80000 90000');
}

// intro to jabroni, this is when he wrestles with the grunt
void jabroniWrestle()	{
	
	//have jabroni play his two animations. I'm sure there are crazy frame commands enroute.
	aiScriptedAnim( $mon_grunt_wrestle, "ad_jump", 1, 0);
	aiScriptedAnimWait( $npc_kovitch, "ad_fights_grunt_1", 1, 0);
	$npc_kovitch.setAnimRate(1.2); // get up faster
	aiScriptedAnim( $npc_kovitch, "ad_fights_grunt_2", 1, 1);
	$npc_kovitch.setAnimRate(1);

	//talk to Kane
//	aiSpeakWait( $npc_kovitch, "lipsync_vo_hello");
	aiSpeak( $npc_kovitch, "lipsync_vo_hello");
	
	//jabroni now follows the player
	$npc_kovitch.setLeader( $player1);
	$npc_kovitch.setTalkState( TALK_OK ); // , "idle");
}

//grunt takes a mean shotgun blast here
void gruntBlasted()		
{
	//blood splatter
	$fx_death_gib.setWorldOrigin( $mon_grunt_wrestle.getJointPos( $mon_grunt_wrestle.getJointHandle( "chest")));
	$fx_death_gib.setAngles( $mon_grunt_wrestle.getAngles());
	sys.trigger( $fx_death_gib);

	//let's see what we can do. We want him to topple ass-over-teakettle, y positive
	$mon_grunt_wrestle.kill();
	sys.waitFrame();
	vector vHead = $mon_grunt_wrestle.getWorldOrigin();
	vHead_z += 48;

	$mon_grunt_wrestle.applyImpulse( $mon_grunt_wrestle, vHead, '0 80000 5000');	
	$mon_grunt_wrestle.applyImpulse( $mon_grunt_wrestle, $mon_grunt_wrestle.getWorldOrigin(), '-1000 50000 4000');	
}


//moves one flyer sprite across the sky over the trenches
void maintainStroggFlyerSprite(entity entMover, entity fxNormal, entity fxDamage, entity entHangar, entity entTgrEnd, vector vDirection)
{	
	sys.wait( sys.random(10) );
	
	//will the planes be swervey?
	float fSwerve = 0;
	float fWaitTime = 0;
	float fAmplitude = 0;

	while(1)	{

		//place the mover on the "hangar" line, equal in the X but displaced in the Y by +/- ___ units

		// +/- Y displacement
		float fDisplacementMax = 2000;
		float fDelta = 0;

		//start location for the flyer
		vector vStart = entHangar.getWorldOrigin();
		vector vSpeed = '0 0 0';
		vector vAngs;

		//flyer speed
		float fSpeed = 900 + (sys.random(600));

		//will the plane be swervey?
		if ( 1 ) {//sys.random(10) < 4)	{
			fSwerve = sys.random(200) + 100;
			fAmplitude = sys.random(90) + 30;
		}
		else	{
			fSwerve = 0;
			fAmplitude = 0;
		}

		//stop the flyer-- move him into position after we figure out where he goes.
		entMover.setLinearVelocity( '0 0 0');

		//mathery mcmath
		fDelta = (0 - fDisplacementMax + sys.random( fDisplacementMax * 2));
		vStart_y += fDelta;

		//faster planes sit lower in the sky
		//vStart_z += (fSpeed / 10);

		//move to position
		entMover.setWorldOrigin( vStart );
		//sys.print("starting at: ");
		//printVector(vStart);
		sys.waitFrame();
		
		//set the direction as speed
		vSpeed = vDirection * fSpeed;	
		vSpeed_z = 0;

		// set initial angle in case this is a non-swerving dude..
		vAngs = sys.VecToAngles(vSpeed);
		entMover.setAngles(vAngs);
	
		//first loop flies up,
		//fWaitTime = sys.getTime() + 4 + sys.random(3);
		fWaitTime = sys.getTime() +  sys.random(2.5);
	
		//turn on the regular plane, turn off the alternate
		fxNormal.start();
		fxDamage.stop();	
		
		//sys.println("Start flight!");
		while( sys.getTime() < fWaitTime)	{
			//fly!
			entMover.setLinearVelocity( vSpeed);

			//swerve if need be
			if( fSwerve != 0)	{
				vSpeed_y = sys.sin( sys.getTime() * fAmplitude ) *  fSwerve;

				// update facing so effects can draw properly
				vAngs = sys.VecToAngles(vSpeed);
				entMover.setAngles(vAngs);
				//sys.println(" swerve = " + vSpeed_y);
			}

			//if somehow the ship has escaped the skybox, break
			if( entMover.touches( entTgrEnd))	{
				//sys.println("early end!");
				break;
			}
			//decend on the way out
			sys.waitFrame();
		}

		//second loop, descend.
		//vSpeed_z *= -1;
		vSpeed_z = 0;

		if(sys.random(20) < 2)
		{
			//sys.println("Damaged!");

			//slow down and fly off course, descend faster
			vSpeed_x *= 0.25;
			if (vSpeed_y < 10 && vSpeed_y > -10)	{
				vSpeed_y += ( -800 + sys.random(1600));
			} else	{
				vSpeed_y *= 4;
			}
			vSpeed_z *= 1.25;

			//no more swerving
			fSwerve = 0;

			//switch to damaged effect, and explode
			fxNormal.stop();
			fxDamage.start();
			$fx_flyer_damage.setWorldOrigin( entMover.getWorldOrigin() );
			sys.trigger( $fx_flyer_damage);
		}
		
		fWaitTime = sys.getTime() +  5;

		//after the possible damage time, remove once the ship has left the skybox
		while( (sys.getTime() < fWaitTime) && ( !entMover.touches( entTgrEnd))  )	{
			//fly!
			entMover.setLinearVelocity( vSpeed);

			//swerve if need be
			if( fSwerve != 0)	{
				vSpeed_y = sys.sin( sys.getTime() * fAmplitude ) *  fSwerve;
				// update facing so effects can draw properly
				vAngs = sys.VecToAngles(vSpeed);
				entMover.setAngles(vAngs);
				//sys.println(" swerve = " + vSpeed_y);
			}

			//decend on the way out
			sys.waitFrame();
		}
		
		//sys.println("End!");
		//run it back!	
	}

	

}

//starts the runs of the three trench fighters
void startTrenchCombat()	{

	//three strafing fighters, this might go.
	//thread maintainFighterStrafe( $mon_fighter_trench_1, 1, 3);
	//thread maintainFighterStrafe( $mon_fighter_trench_2, 3, 3);
	//thread maintainFighterStrafe( $mon_fighter_trench_3, 2, 3);

	sys.trigger( $radio_walker_trench_1);

	//walkers
	thread walkerOne();
	thread walkerTwo();

	thread trenchStrafeRun();

	//flyer
//	thread flyerTrenchLoop();

	//big gun in action - NOTE: currently started from main because the global lighting
	//	thing Roger set up is rigged into this.  At some future point, maybe it
	//	would be better to have a function that handles the flashes until we get to this
	//	point, then we kill the other thread and let the read dude take over that task
//	thread maintainBigGun();

	//marine holding the trench
	thread marineOnTrenchWall($npc_judkins);
	thread marineOnTrenchWall($npc_ripkey);

	//asplosions
	thread maintainSecondTrenchExplosions();
	thread maintainFirstTrenchExplosions();
}

//an actual strogg fighter flying along, keeping the marines pinned down.
void maintainFighterStrafe(entity entFighter, float fValue, float fMaxPlaybacks)	{

	entFighter.show();
	string strPlaybackDef = "playback_ad_trench_";
	
	while(1)	{
	
		while(fValue <= fMaxPlaybacks)	{
			sys.wait(sys.random(10));
			entFighter.setHealth(200);
	
			//fly along the path
			aiScriptedPlaybackMoveWait ( entFighter, "playback_ad_trench_" + fValue, PBFL_GET_POSITION | PBFL_GET_ANGLES_FROM_VEL, 4);
			fValue++;

			//if the fighter got blown up, quit out of this loop
			if( entFighter == $null_entity)	{
				return;
			}
		}
		fValue = 1;
		sys.waitFrame();
	}

}

//pipes burst, grunt spews out, oh it's good times.
void pipeBustin()	{

	//bursty pipes!
	$env_airdefense_pipes_1.show();
	$func_static_temppipes.remove();
	$env_airdefense_pipes_1.playAnim(ANIMCHANNEL_ALL, "bustin_open");

	sys.trigger( $fx_pipebust_2);
	sys.trigger( $fx_pipebust_3);
	sys.trigger( $fx_pipebust_4);
	sys.trigger( $spkr_grunt_pipes);

	//aggro grunt!
	aiScriptedAnimWait( $mon_grunt_pipes, "ad_bustin_pipes", 4, 1);
	$mon_grunt_pipes.setEnemy( $player1);
}

//knocks the player back from the grunt's busting pipes
void playerKnockback()	{

	vector vKnockback;
	vector vGrunt = $mon_grunt_pipes.getWorldOrigin();
	vector vPlayer = $player1.getWorldOrigin();
	
	vKnockback = VectorSubtract( vPlayer, vGrunt);
	vKnockback = sys.vecNormalize( vKnockback);

	//high numbers? Yes but they work very well.
	vKnockback *= 1000000;
	vKnockback_z = 2000000;
	
	//now for the jiggery pokerey-- too bad we can directly applyImpulse to player1...
	$player1.bind( $mvb_pipehit);

	//the player is bound to the invisible moveable, so knock it back-- along with the player.
	$mvb_pipehit.applyImpulse( $mvb_pipehit, $mvb_pipehit.getWorldOrigin(), vKnockback);

	// Ah yes, 'they' have agreed allow the player to take the single point of damage!!  So, bye bye health pack hack.
	if ( $player1.getHealth() > 1 ) 
	{
		$mon_grunt_pipes.directDamage( $player1, "damage_triggerhurt_1" );
		//	entity entCrybaby = sys.spawn("item_health_oneHP_silent");
		//	entCrybaby.setWorldOrigin( $player1.getWorldOrigin());
	}

	sys.wait( .25);

	//yes, smoke _and_ mirrors, together at last
	$player1.unbind();
	$mvb_pipehit.remove();

}

//send the grunt running toward the pipes, but it's all hokum, we'll just teleport him to the
//right spot when it's time to make him smash
void gruntRunToPipes()	{

	//position
	$mon_grunt_fake_pipes.setWorldOrigin( $tgt_grunt_pipes_start.getWorldOrigin() );

	//run!
	aiScriptedMoveWait( $mon_grunt_fake_pipes, $tgt_grunt_pipes_end, 1, 0);

	//poof!
	$mon_grunt_fake_pipes.remove();

}

//runs an injured marine through pain anims
void injuredMarineLoop(entity marine, entity doctor)	
{
	sys.wait(17);

	//the medic speaks to his comm radio
	sys.trigger( $spkr_anderson_1);

	sys.wait(3.2);
	aiSpeakWait( doctor, "lipsync_vo_1_1_1_15_2");

	sys.trigger( $spkr_anderson_2);
	sys.wait(1.6);

	aiSpeakWait( doctor, "lipsync_vo_1_1_1_15_4");
//	aiScriptedStop( doctor);	

	//set the talk state for the medic, he won't do much except heal this guy
	doctor.setTalkState( TALK_OK ); // , "medic_treating");
}	

//morris has a conversation with his radio over the introduction
void morrisIntroLoop()	
{
	$npc_morris_intro.hideSurface("models/weapons/mp_guns/w_mg_lo");
	aiScriptedAnimLoop( $npc_morris_intro, "working_wall_panel_3", 0);
	
	sys.wait(12);
	if( g_morrisMeetsKane == 0 )	{
		thread _morrisIntroLoop();
	}
}

void _morrisIntroLoop()	
{
	sys.wait(10);
	//voss radios in
	sys.trigger( $spkr_voss_intro_1);
	sys.wait(3.5);

	//morris replies
	aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_28_1");
	sys.wait(0.5);

	//voss radios in again
	sys.trigger( $spkr_voss_intro_2);
	sys.wait(6);

	while( isValidEntity($npc_morris_intro)) // while (1)
	{
		//now, Morris says these things in a loop until the player gets close enough to use him.
		aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_1");
		sys.wait(4);
		aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_2");
		sys.wait(4);
		aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_3");
		sys.wait(4);
	}
}

//this is morris talking to the player
void morrisIntroTalkToPlayer()	
{
	//kill the intro loop thread
	sys.killthread( "map_airdefense::_morrisIntroLoop");
	sys.killthread( "_morrisIntroLoop");

	// ensure that morris is done speaking before we start him looking at the player, otherwise
	//	he can cut off his HQ, HQ, do you read?  lines..
	while ( $npc_morris.isSpeaking())
	{
		sys.println( "morris waiting to speak" );
		sys.wait(.1);
	}

	g_morrisMeetsKane = 1;

	// morris talks to the player - let morris look at the player for a second before initiating the conversation
	$npc_morris_intro.lookAt( $player1 );
	aiScriptedAnim( $npc_morris_intro, "ad_morris_intro", 12, 1);
	sys.wait(1.75);

	aiSpeak( $npc_morris_intro, "lipsync_vo_1_1_1_40_1");

	while ( $npc_morris_intro.isSpeaking( ))
	{
		sys.waitFrame();
	}

	aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_40_2");
//	aiScriptedAnim( $npc_morris_intro, "weaponless_point_left", 8,0);
	aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_40_3");
	$npc_morris_intro.lookAt( $null_entity );

	sys.trigger( $objectiveIntro);
//	sys.wait(4);
//	aiScriptedStop( $npc_morris_intro);

	// now morris can be queried.
//	aiScriptedAnimLoop( $npc_morris_intro, "working_wall_panel_3", 4);
//	$npc_morris_intro.setTalkState( TALK_OK ); // , "working_wall_panel_3");
	sys.wait(4);

	while( isValidEntity($npc_morris_intro)) // while (1)
	{
		//now, Morris says these things in a loop until the player gets close enough to use him.
		if( !$npc_morris_intro.isSpeaking() )
			aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_1");
		sys.wait(5);
		
		if( !$npc_morris_intro.isSpeaking() )
			aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_2");
		sys.wait(5);
		
		if( !$npc_morris_intro.isSpeaking() )
			aiSpeakWait( $npc_morris_intro, "lipsync_vo_1_1_1_30_3");
		sys.wait(5);
	}
}

//this is a different marine, skewered differently... uh, yeah
/*void introMarineShishkabob()	{

	aiScriptedAnimLoop( $npc_cliff, "ad_wounded_on_knee_loop", 1);
	
	while(1)
	{
		sys.trigger( $spkr_intro_kabob_1);
		sys.wait( sys.random(3) + 2);

		sys.trigger( $spkr_intro_kabob_2);
		sys.wait( sys.random(3) + 2);

		sys.trigger( $spkr_intro_kabob_3);
		sys.wait( sys.random(3) + 2);
	}
}
*/

//handle the dead and skewered marine
void skewerMarine()	
{
	$marine_skewer.lookAt( $player1 );
	aiSpeak( $npc_redshirt_1, "lipsync_vo_1_1_2_09_1" );

	sys.trigger( $spkr_berserker_cue);
	aiScriptedAnim( $mon_berserker_skewer, "ad_intro", 1, 1);
	aiScriptedAnimWait( $marine_skewer, "ad_berserker_intro", 1, 0);

	//anything else here?
	$marine_skewer.kill();
	sys.waitFrame();
	$marine_skewer.stopThinking();
	$marine_skewer.becomePassive(true);
	$marine_skewer.disableTarget();
	$marine_skewer.takeDamage(0);
	$marine_skewer.disablePain();

	$mon_berserker_skewer.setEnemy($player1);
	sys.trigger( $fx_skewer_pool);

	//kill the marine
//	sys.wait(1);
}

// open the doors for the skewering berserker.  Called via framecommands from ad_berserker_intro
void openSkewerDoors()	
{
	$door_skewer_1.lock(0);
	$door_skewer_2.lock(0);
	$grunt_door_1.lock(1);
	$door_postMedic_1.lock(0);
}

//strafe the tunnel in the trench!
void tunnelBomb()	
{
	// bombxor!!
	sys.trigger( $fx_tunnel_bomb_1);
	sys.wait(0.2);
//	sys.trigger( $fx_tunnel_bomb_2);
//	sys.wait(0.2);
	sys.trigger( $fx_tunnel_bomb_3);
	//dust from inside the tunnel
	sys.trigger( $fx_tunnel_dust_1);
	sys.trigger( $fx_tunnel_dust_2);
	sys.trigger( $fx_tunnel_dust_3);

	sys.wait(0.4);
	sys.trigger( $fx_tunnel_bomb_4);
//	sys.wait(0.4);
//	sys.trigger( $fx_tunnel_bomb_5);
	sys.wait(0.1);
	sys.trigger( $fx_tunnel_bomb_6);
	sys.wait(0.7);
	sys.trigger( $fx_tunnel_bomb_7);

	//blow up the second walker
	$death.directDamage( $walker_trench_2, "damage_gib");
}

void fireTrenchRocket(string rocketTarget)	{

	entity entDest;

	//if no target, pick one at random
	if( rocketTarget == "") {
		entDest = $tgt_rocket_dest.randomTarget( "null" );
	} else	{
		entDest = sys.getEntity(rocketTarget);
	}

	entity entRTarget;
	entity entRLaunch;

	//there's two projectile launchers, fire one of them
	if( sys.random(10) < 5)	{
		entRLaunch = $projectile_bunker_2;
	}	else	{
		entRLaunch = $projectile_bunker_1;
	}
	
	//move the launcher's target to a random destination and fire
	entRTarget = entRLaunch.getTarget(0);
	entRTarget.setWorldOrigin( entDest.getWorldOrigin());
	sys.trigger( entRLaunch);
}

void trenchStrafeRun()
{
	return;
//	sys.wait(4);
//	$strogg_flyer_trench_2.show();
//	$strogg_flyer_trench_2.playAnim( ANIMCHANNEL_ALL, "ad_strafe3" );
}

void trenchStrafeRun2()
{
	return;
//	sys.wait(3);
//	$strogg_flyer_trench_2.show();
//	$strogg_flyer_trench_2.playAnim( ANIMCHANNEL_ALL, "ad_strafe3" );
}

//----------------------------------------------------------------------------------------------------
void strafeFlyerShoot( float preDelay, entity projectileOne, entity projectileTwo, float burst )	
{
	sys.wait(preDelay);
	while( burst > 0 )
	{
		// Fire away!
		sys.trigger( projectileOne );
		sys.wait( 0.03 );
		sys.trigger( projectileTwo );
		sys.wait( 0.1 );
		
		// decrement burst counter
		burst--;
	}
}
void walkerShoot( entity driver, entity vehicle )
{
	while ( isValidEntity(vehicle) && isValidEntity(driver) && vehicle.getHealth() > 0 )
	{
		driver.fireWeapon(0,.1);
		sys.wait(sys.random(.5)+.2);
	}
}
void driveWalkerToDeath()
{
	$aiDriver_1.enterVehicle( $walker_trench_1 );
	aiScriptedMove( $aiDriver_1, $tgt_trench_walker_1, 32, 0 );
	walkerShoot($aiDriver_1, $walker_trench_1);
}
void doWalkerKill()
{
	sys.wait(1.8);
	aiScriptedAnimWait( $walker_trench_1, "knocked_down", 0, 0);
	sys.wait(.8);
	$death.directDamage( $walker_trench_1, "damage_gib");
}
void stroggStrafeRun()	
{
	thread driveWalkerToDeath();
	sys.wait(2.5);

	// Show fighter
	$stroggFighter_1.show();
	sys.trigger($speaker_8);
	sys.trigger($func_fx_772);

	// Start on spline path and bank accordingly
	$stroggFighterBase_1.startSpline( $stroggFighterFlyover );
	$stroggFighter_1.rotateOnce( '0 0 0' );
	sys.waitFor( $stroggFighter_1 );
	$stroggFighter_1.rotateOnce( '15 0 0' );
	sys.waitFor( $stroggFighter_1 );
	thread strafeFlyerShoot( 1, $target_launchprojectile_5, $target_launchprojectile_6, 8);
thread doWalkerKill();
	$stroggFighter_1.rotateOnce( '-30 0 0' );
	sys.waitFor( $stroggFighter_1 );
	$stroggFighter_1.rotateOnce( '-90 0 0' );
	
	// Wait for base to reach destination, then hide fighter
	sys.waitFor( $marineFighterBase_1 );
	$stroggFighter_1.hide();	
}
//----------------------------------------------------------------------------------------------------


// Walker one, the one that gets hit and all blowed up
//----------------------------------------------------------
void walkerOne()	
{
	thread  maintainTrenchRockets();
	thread  stroggStrafeRun();
	//put the driver in the walker
/*	$aiDriver_1.enterVehicle( $walker_trench_1);
	
	//walk
	sys.wait(1);
	thread walkerFireManager( $aiDriver_1);
	aiScriptedMoveWait( $aiDriver_1, $tgt_trench_walker_1, 1, 1);
	
	//blow it up
	sys.wait(4);
	fireTrenchRocket( "tgt_hit_walker_1" );
	aiScriptedAnimWait( $walker_trench_1, "knocked_down", 0, 0);

	sys.wait(1);
	$death.directDamage( $walker_trench_1, "damage_gib");
*/
}

void walkerTwo()	
{
	//put the driver in the walker
	$aiDriver_2.enterVehicle( $walker_trench_2);
	sys.wait(3);
	thread walkerFireManager( $aiDriver_2);
	sys.wait(3);
	aiScriptedMove( $aiDriver_2, $tgt_trench_walker_2, 1, 1);
}

//determines which cool walker firing anim he'll use
void walkerFireManager(entity entDriver)	
{
	entDriver.setKey("alive", "true");

	//shoot like mad!
	while(entDriver.getKey("alive") == "true")	
	{
		float fFire = sys.random(100);

		if(fFire < 14)
		{
			$aiDriver_2.fireWeapon( 0, 0.1);
		}
		else if (fFire < 20)	
		{
			float fBurst = 0;
			for( fBurst = 0; fBurst < 10; fBurst++)	
			{
				$aiDriver_2.fireWeapon( 1, 1);
				sys.wait(0.05);
			}
		}
		
		sys.waitFrame();
	}
}

//maintains the flyer over the trenches
void flyerTrenchLoop()	{

	$flyer_trench_strafe.show();
	$flyer_trench_strafe.playCycle( ANIMCHANNEL_ALL, "ad_strafe");

	thread flyerRocketLoop();

	while(1)	{
		
		if( g_trenchTwoEffects == 1 && ( (sys.random(100) < 30) ||  g_flyerInRange == 1) )	{

			//do some shootin
			float fShoot = sys.getTime() + 4;
			while( sys.getTime() < fShoot)	{
				
				sys.trigger( $tgt_flyergun_left);
				sys.wait(0.1);
				sys.trigger( $tgt_flyergun_right);
				sys.wait(0.1);
			
				if( sys.random(20) < 1)	{
					sys.trigger( $tgt_flyergun_rocket);
				}
			}
		}
		
		sys.wait(2);
	}

}

//this assumes the flyer is in rocket range
void flyerRocketLoop()	{
	
	while(1)	{
		if(g_flyerInRange == 1 && g_trenchTwoEffects == 1)	{
			sys.trigger( $tgt_flyergun_rocket);
			sys.wait(0.1 + sys.random(0.3));
		}
		sys.wait(0.1);
	}
}

//keeps the marine ducking when underfire, 
void marineCowerLoop(entity entMarine, string strAnim)	{

	//this marine is set to cower
	entMarine.setKey("cower","yes");	

	while (entMarine.getKey("cower") == "yes")	{
		
		//if the flyer is shooting at the right area, start ducking
		if (g_flyerInRange == 1)	{

			sys.wait( sys.random(1));

			aiScriptedAnimWait( entMarine, "cowering_start", 12, 0);
			aiScriptedAnimLoop( entMarine, "cowering_idle", 12);

			//while he's cowering wait for the all clear
			while( entMarine.getKey("cower") == "yes" && g_flyerInRange == 1)	{
				sys.wait(sys.random(1.5));
			}
			
			//get up and return to idle
			aiScriptedAnimWait( entMarine, "cowering_end", 12, 0);
			aiScriptedAnimLoop( entMarine, strAnim, 12);

		}

		sys.wait(sys.random(1));
	}

}


//fires an FX rocket from one point to another
void fireFXRocket(entity mvr, entity entFx, entity entStart, entity dest, entity impactEffect, float fSpeed) {

	//orient and start the effect
	entFx.appendTarget( dest);
	entFx.start();

	//slam it into the target
	mvr.setWorldOrigin( entStart.getWorldOrigin() );
	mvr.speed( fSpeed);
	mvr.moveTo( dest);
	sys.waitFor( mvr);
	//sys.println(" Collision! ");
	mvr.setWorldOrigin( entStart.getWorldOrigin() );
	
	//play the hit effect
	entFx.stop();
	entFx.removeTarget( dest);
	impactEffect.setWorldOrigin( dest.getWorldOrigin() );
	impactEffect.start();

	//sys.println(" fireFXRocket over!");

}


//---------------------------------------------------------------------------------
// void triggerBigGunDust()
//
// This function triggers entities func_fx_cannondust_1 -> func_fx_cannondust_53
//---------------------------------------------------------------------------------
void triggerBigGunDust()
{
	entity ent;
	float fCt;

	// currently there are 1-53 of these bad boys
	for ( fCt=1; fCt<=53; fCt=fCt+1 )
	{
		ent = sys.getEntity( "func_fx_cannondust_" + fCt );
		if ( ent == $null_entity )
		{
			break;
		}
		sys.trigger(ent);
	}
}

//---------------------------------------------------------------------------------
void manageBigGunCharging()
{
	$airdefense_big_gun.setShaderParm(4,sys.getTime());
	sys.wait(1);
	sys.trigger( $fx_biggun_charge);
	sys.trigger( $fx_biggun_charge_1);
	sys.wait(3);
	$airdefense_big_gun.setShaderParm(4,0);
}

//this should get the big gun to turn and fire
void maintainBigGun()	{

	float fAngle = 0;
	float fNewAngle = 0;
	fAngle = $mvr_biggun.getFloatKey("angle");
	$mvr_biggun.time(5);

	$ai_biggun_driver.enterVehicle( $airdefense_big_gun);

	$mvr_biggun.accelTime(2);
	$mvr_biggun.decelTime(2);

	while(1)	{

	/*
		//put the gun blast back in place... grr...
		$fx_biggun_fly.stop();
		$mvr_biggun_blast.unbind();	
		$mvr_biggun_blast.setLinearVelocity('0 0 0');
		$mvr_biggun_blast.setWorldOrigin( $fx_biggun_fire.getWorldOrigin() );
		//wait a frame and bind it to the biggun mover
		sys.waitFrame();
		$mvr_biggun_blast.bind( $mvr_biggun);
		$tgt_biggun_fire.bind( $mvr_biggun);
	*/

		//between 90 and 270
		fNewAngle = (270 + sys.random(180));
		if( fNewAngle >= 360)
			fNewAngle -= 360;

		//rotate up to, rotate down to...
		/*
			0 degrees is pointing "north", 90 is east and 270 is west. So, 
			A little bit of math jiggery pokery here

		*/

		//charge up the shot before rotation
		

		//if both angles are in the same quadrant...
		if ((fNewAngle >= 270 && fAngle >= 270) || (fNewAngle <= 90 && fAngle <= 90))
		{
			if (fNewAngle < fAngle)	{
				$mvr_biggun.rotateDownTo( 1, fNewAngle);
			}	else	{
				$mvr_biggun.rotateUpTo( 1, fNewAngle);
			}
		}
		//new in q I, old in q IV -- rotate up (clockwise)
		else if (fNewAngle <= 90 && fAngle >= 270)
		{
			$mvr_biggun.rotateUpTo( 1, fNewAngle);
		} 
		//new in q IV, old in q I, rotate down (counter clockwise)
		else if (fNewAngle >= 270 && fAngle <= 90)
		{
			$mvr_biggun.rotateDownTo( 1, fNewAngle);
		}
		
		//the move is five seconds long, the wait before the fire is .75 seconds.
		//so that's 5.75. The effect is 4 seconds long... about...
		sys.wait( 2.5 );
		
		thread manageBigGunCharging();

		//now wait for the move to finish.
		sys.waitFor( $mvr_biggun);
		sys.wait(0.75);
		
		//fire!
//		$airdefense_big_gun.playAnim( ANIMCHANNEL_ALL, "fire");
//		aiScriptedAnim( $airdefense_big_gun, "fire", 4, 1);
		$ai_biggun_driver.fireWeapon(0,1);
		sys.trigger( $spkr_big_gun_muffled );

		// set global lighting change, create some dust...
		sys.setShaderParm(1, sys.getTime());
		thread triggerBigGunDust();

	//	$ai_biggun_driver.fireWeapon(1,1);
	//	$ai_biggun_driver.fireWeapon(2,1);

		/*
		sys.trigger( $fx_biggun_fly);
		sys.trigger( $fx_biggun_fire);

		//move the projectile away
		vector vBlastDir = $fx_biggun_fly.getWorldOrigin() - $tgt_biggun_fire.getWorldOrigin();
		vBlastDir = sys.vecNormalize( vBlastDir);
		vBlastDir *= -1000;

		//unhitch the projectile mover from the base, and bind the target for the projectile to the projectile.
		$mvr_biggun_blast.unbind();
		$tgt_biggun_fire.bind( $mvr_biggun_blast);

		sys.waitFrame();
		//printVector( vBlastDir);
		//sys.print("mvr_biggun_blast at: ");
		//printVector( $mvr_biggun_blast.getWorldOrigin() );

		$mvr_biggun_blast.setLinearVelocity( vBlastDir);
		*/

		// revert global lighting..roger had this set up with a 4 second delay from triggering, so I'm keeping that aspect of it
		sys.wait(4);
		sys.setShaderParm(1, 0);

		// add a small amount of additional wait.
		sys.wait( sys.random(1.5));

		fAngle = fNewAngle;
	}

}

//reveal the team
void prepareConversation()	
{
	sys.trigger( $npc_rhodes);
	sys.trigger( $npc_bidwell);
	sys.trigger( $npc_sledge);
	
	$npc_rhodes.becomePassive(true);
	$npc_bidwell.becomePassive(true);
	$npc_sledge.becomePassive(true);

	$npc_rhodes.disableTarget();
	$npc_bidwell.disableTarget();
	$npc_sledge.disableTarget();

	//aiScriptedAnimLoop( $npc_rhodes, "crouch_idle", 1);
	//aiScriptedAnimLoop( $npc_bidwell, "crouch_idle", 1);
//	aiScriptedAnimLoop( $npc_sledge, "crouch_cover_left_idle", 1);

//	thread marineCowerLoop( $npc_sledge, "crouch_idle" );
//	thread marineCowerLoop( $npc_rhodes, "crouch_cover_left_idle");
}

void bidwellCallPlayer()
{
	// bidwell motions to the player to come over
	$npc_bidwell.setAnimRate(1.2);
	aiScriptedAnimWait( $npc_bidwell, "wave_over", 4, 1);
	$npc_bidwell.setAnimRate(1);

	$npc_bidwell.lookAt( $player1 );
//	aiScriptedMoveWait( $npc_bidwell, $tgt_bidwell_trench_dest, 12, 0);
//	aiScriptedFace( $npc_bidwell, $player1, 0);
//	aiScriptedAnimLoop( $npc_bidwell, "crouch_idle", 1);
//	thread marineCowerLoop( $npc_bidwell, "crouch_idle");
}

//the conversation in the trench between four NPCs and the player
void trenchConversation()	
{
	// the player has just rounded a corner, and should see Sledge, Bidwell and Rhodes taking
	// some cover in an open area of the trench. rhodes is disappointed-- he lost the bet
	$npc_bidwell.lookAt( $player1 );
	$npc_rhodes.lookAt( $player1 );
	aiScriptedAnim($npc_rhodes, "crouch_idle", 12, 0 );

sys.trigger($tgt_fade_sounds_for_vo); // utilize sound class to reduce background noize so VO can be heard

	sys.wait(0.5);
	aiSpeakWait( $npc_rhodes, "lipsync_vo_1_1_3_80_1" );	// so you are alive!
	aiScriptedAnim( $npc_rhodes, "ad_cover_2", 12, 0 );
	$npc_rhodes.lookAt( $null_entity );

//	aiScriptedFace( $npc_bidwell, $player1, 1);
	// here comes Morris, talking as he runs.
	$npc_bidwell.lookAt( $npc_morris );
	aiScriptedMove( $npc_morris, $tgt_morris_trench_dest, 32, 1);
	sys.wait(2);
	aiSpeakWait( $npc_morris, "lipsync_vo_1_1_3_80_2");	 // hello ladies!

	sys.wait(0.15);

	// bidwell explains that we're stuck
	aiSpeak( $npc_bidwell, "lipsync_vo_1_1_3_80_3" ); // we're just getting started.
	// wait a total of 7.3 seconds... // do it this way because bidwell is supposed to get cut off.  A slight VO overlap feels better, IMO.
	sys.wait(4.3);
	$npc_bidwell.lookAt( $player1 );
	sys.wait(1.5);
	$npc_bidwell.lookAt( $morris );
	sys.wait(1.5);

	// voss pipes up over the radio
	sys.trigger( $radio_voss_trench_1);	//  ~5.4 secs
	sys.wait(5.4);

	aiScriptedFaceWait( $npc_bidwell, $npc_rhodes, 0 );
	aiScriptedAnimWait( $npc_bidwell, "ad_cover3_guistart", 12, 0 );
	aiScriptedAnimLoop( $npc_bidwell, "ad_cover3_guiloop", 4 );
	// bidwell replies
	aiSpeakWait( $npc_bidwell, "lipsync_vo_1_1_3_80_5" ); // he's right here, sir!
	aiScriptedAnim( $npc_bidwell, "ad_cover3_guiend", 12, 0 );

	// voss pipes up over the radio
	sys.trigger( $radio_voss_trench_2); // ~8.5 secs

	// wait for bidwell to finish his anim, then transition back to his idle anim
	while ( ! aiScriptedDone( $npc_bidwell))
	{
		sys.waitFrame();
	}
	aiScriptedAnim( $npc_bidwell, "ad_cover3_loop", 12, 0 );

	sys.wait(7);

	// bidwell replies-- you've got your orders so go!
	aiSpeak( $npc_bidwell, "lipsync_vo_1_1_3_80_7" ); // you heard the man, kane
	sys.trigger( $objectiveHangar);

	//morris follows you.
	$npc_morris.setLeader( $player1);
	$npc_morris.enableTarget();
	$npc_morris.becomeAggressive();

	aiSpeakDone( $npc_bidwell );
sys.trigger($tgt_restore_sounds_after_vo); // utilize sound class to restore background noize levels

}

//handles a marine who is guarding the trenches
void marineOnTrenchWall(entity entMarine)	
{
	while(entMarine)	
	{
		//put this marine into a kneeling / fighting pose
		aiScriptedAnimLoop( entMarine, "crouch_cover_idle", 4);

		sys.wait(2 + sys.random(4));
		float fPhrase = sys.random(50);

		if (fPhrase < 10)
			fPhrase = 1;
		else if (fPhrase < 20)
			fPhrase = 2;
		else if (fPhrase < 30)
			fPhrase = 3;
		else if (fPhrase < 40)
			fPhrase = 4;
		else 
			fPhrase = 5;

		//shoot, say the phrase
		aiSpeak( entMarine, "lipsync_trench_jive_" + fPhrase);
		aiScriptedAnimWait( entMarine, "crouch_popup_shoot", 4, 0);
		aiScriptedAnimWait( entMarine, "crouch_cover_reload", 4, 0);			
	}
}

//maintains the trench rockets: none of them will hit.
void maintainTrenchRockets()	{
	
	entity entTarget;
	entity entDest;

	while(1)	{
		
		if( g_trenchOneEffects)	{
			fireTrenchRocket( "");			
		}

		sys.wait(0.5 + sys.random(0.5));

	}

}

//fired when the player pics up the medic.
void gotMedic()	
{
	sys.trigger( $npc_anderson );
	sys.waitFrame();

	// bind the gun into his hand;
	float hnd = $npc_anderson.getJointHandle( "l_wrist" );
	vector angs = $npc_anderson.getJointAngle( hnd );
	$func_anderson_vaccinegun.setAngles( angs );

	// ugh, hacking position
	vector origin = $npc_anderson.getJointPos( hnd ) + (sys.angToRight(angs) * 6);
	origin = origin + (sys.angToForward(angs) * 2);
	origin = origin + (sys.angToUp(angs) * 2);

	$func_anderson_vaccinegun.setOrigin( origin );
	$func_anderson_vaccinegun.bindToJoint( $npc_anderson, "l_wrist", 1 );

	sys.waitFrame();
	// now hide it until he needs to use it.
	$func_anderson_vaccinegun.hide();

	//set this off
	sys.trigger( $trigger_relay_returnwithmedic);

	//assign the medic to the player
	$npc_anderson.setLeader( $player1);
	$npc_anderson.lookAt( $player1 );	

	// get into range, then speak his vo
	aiScriptedMoveWait( $npc_anderson, $player1, 200, 1);

//	aiScriptedFaceWait( $npc_anderson, $player1, 1);
	aiSpeak( $npc_anderson, "lipsync_vo_1_1_2_10_1"	);

	//trigger the next medic trigger
	sys.trigger( $tgr_bring_medic);

	sys.wait(3);
	//let's keep Anderson thinking:
	thread medicHealingCheck( $npc_anderson);
	$npc_anderson.lookAt( $null_entity );	
	$npc_anderson.setTalkState( TALK_OK ); // , "idle");
}

//used to manage the tracers out in the trenches
void activateTrenchTracers(float fStart, float fEnd)	{

	float t;
	entity entFx;

	for (t = fStart; t<= fEnd; t++)	{
		sys.getEntity( "fx_tracer_trench_" + t).start();
	}

}

void deactivateTrenchTracers(float fStart, float fEnd)	{

	float t;
	entity entFx;

	for (t = fStart; t<= fEnd; t++)	{
		sys.getEntity( "fx_tracer_trench_" + t).stop();
	}

	sys.println("Tracers off");
}





// This will turn on all the effects in trench one (the west one)
void activateTrenchOneEffects()	{

	//turn on tracers 0 - 13
	activateTrenchTracers(0, 13);

	//enable the rocket attacks
	g_trenchOneEffects = 1;

}

//and this will turn them all off
void deactivateTrenchOneEffects()	{

	//turn off tracers 0 - 13
	deactivateTrenchTracers(0, 13);

	//enable the rocket attacks
	g_trenchOneEffects = 0;

}


// This will turn on all the effects in trench two, on the east
void activateTrenchTwoEffects()	{

	//turn on tracers 14- 26
	activateTrenchTracers(14, 26);
	g_trenchTwoEffects = 1;

}

//and this will turn them all off
void deactivateTrenchTwoEffects()	{

	//turn on tracers 14- 26
	deactivateTrenchTracers(14, 26);
	g_trenchTwoEffects = 0;

}
/*
//this will play an ambient sound in the level along with a VO.
//the wait time will be the delay from the start of the 
void playAmbientWithVO( float speakerID, float waitTime)	{
	sys.trigger( sys.getEntity("spkr_ambient_" + speakerID));
	sys.wait( waitTime);
	sys.trigger( sys.getEntity("spkr_ambient_" + speakerID + "_vo"));
}
void playAmbient_1()	{
	playAmbientWithVO( 1, 3);
}
void playAmbient_2()	{
	playAmbientWithVO( 2, 1);
}
void playAmbient_3()	{
	playAmbientWithVO( 3, 1);
}
void playAmbient_4()	{
	playAmbientWithVO( 4, 2.5);
}
void playAmbient_5()	{
	playAmbientWithVO( 5, 3);
}
*/

//random explosions in the second trench
void maintainSecondTrenchExplosions()	{

	float fNum = 0;

	while(1)	{

		if(g_trenchTwoEffects)	{
			
			fNum = sys.random(8);
			fNum *= 1000;
			fNum = (fNum % 7) + 1;
			sys.trigger( sys.getEntity( "fx_foom_trench_second_" + fNum));
			sys.println("Exploding number " + fNum);
		}

		sys.wait( sys.random(4));
	}
}

void maintainFirstTrenchExplosions()	
{
	float fNum = 0;

	while(1)	
	{
		if(g_trenchOneEffects)	
		{
			fNum = sys.random(8);
			fNum *= 1000;
			fNum = (fNum % 7) + 1;
			sys.trigger( sys.getEntity( "fx_foom_trench_first_" + fNum));
			sys.println("Exploding number " + fNum);
		}

		sys.wait( sys.random(4));
	}
}

//---------------------------------------------------------------------------
// 
// Badger Squad scenarios
//
//---------------------------------------------------------------------------

// A trio of badger squad are fighting off a strogg, just finishing them up when the player walks in.
void marineBattleInBuilding()	
{
	sys.trigger( $mon_strogg_redshirt_1 );
	sys.trigger( $npc_chase );

	// hillstrom gets ready to pound on some stogg butt
	aiScriptedAnimLoop( $npc_hillstrom, "crouch_idle", 4 );
	$npc_hillstrom.setEnemy( $mon_strogg_redshirt_1);

	// This strogg ain't got a chance...
	$mon_strogg_redshirt_1.setEnemy( $npc_hillstrom);
	sys.wait(.65);

	// hillstrom prepares to blow the strogg away
	aiScriptedAnim( $npc_hillstrom, "crouch_range_attack", 4, 0);

	// four frames... this is a hack but cool
	sys.waitFrame();
	sys.waitFrame();
	sys.waitFrame();
	sys.waitFrame();

	// gibs -- doesn't really matter if the guy is dead or not at this point.
	vector vGib = $mon_strogg_redshirt_1.getWorldOrigin();
	vGib_z += 42;

	// move the effect into place and set it off
	$fx_death_gib.setWorldOrigin( vGib);
	$fx_death_gib.setAngles( $mon_strogg_redshirt_1.getAngles());
	sys.trigger( $fx_death_gib);
	
	// hillstromg kills the strogg
	$npc_hillstrom.directDamage( $mon_strogg_redshirt_1, "damage_triggerhurt_5");
	sys.waitFrame();	
	$mon_strogg_redshirt_1.applyImpulse( $mon_strogg_redshirt_1, $mon_strogg_redshirt_1.getWorldOrigin(), '0 60000 10000');

	aiScriptedMove( $npc_miller, $tgt_miller_here, 4, 1 );

	// the rest of the badger scene can now progress (once the player gets close enough to trigger it)
	g_badgerSceneReady = 1;
}

//------------------------------------------------------------------
void startBadgerScene()	
{
	// this loops depends on the completion of func marineBattleInBuilding()
	while( g_badgerSceneReady == 0)	
	{
		sys.wait(0.25);
	}

	// make miller, chase and hillstrom all non-combatants
	$npc_miller.disableTarget();
	$npc_hillstrom.disableTarget();
	$npc_chase.disableTarget();
	$npc_kovitch.disableTarget();
	
	thread millerHelpsWoundedMarine();
	thread kovitchIdle();
}	

//------------------------------------------------------------------
void kovitchIdle()	
{
	aiScriptedMoveWait( $npc_kovitch, $tgt_kovitch_here, 4, 0);
	aiScriptedFaceWait( $npc_kovitch, $npc_chase, 0);
	$npc_kovitch.setTalkState( TALK_OK ); // , "talk_idle");
	$npc_kovitch.setLeader( $null_entity);
}

//------------------------------------------------------------------
void hillstromHelpsWoundMarine()
{
	$npc_hillstrom.setOrigin( $tgt_hillstrom_start.getOrigin());
	$npc_hillstrom.setAngles( $tgt_hillstrom_start.getAngles());

	aiScriptedAnim( $npc_chase, "mhstrom_wounded_a", 4, 0 );
	aiScriptedAnimWait( $npc_hillstrom, "mhstrom_wounded_b", 4, 0 );

	aiScriptedAnimLoop( $npc_chase, "mhstrom_loop_a", 4 );
	aiScriptedAnimLoop( $npc_hillstrom, "mhstrom_loop_b", 4 );

	// hillstrom makes sure the area is secure, then checks out chase for a bit
	sys.wait(16);

	// ...then goes back to guard duty
	$npc_hillstrom.setMoveSpeed( AIMOVESPEED_WALK );
	aiScriptedMoveWait( $npc_hillstrom, $tgt_hillstrom_here, 4, 0);
	aiScriptedAnimWait( $npc_hillstrom, "stand_to_crouch", 16, 0 ); // damn it popping, go away..

	$npc_hillstrom.becomePassive(true);
	aiScriptedAnimLoop( $npc_hillstrom, "crouch_idle", 16 );
}

//------------------------------------------------------------------
// Miller checks out the wounded marine and calls out for help, but
//	signal is jammed - damn squibs!  Only Kane can save us now..
//------------------------------------------------------------------
void millerHelpsWoundedMarine()	
{
	$npc_miller.becomePassive(true);
	aiScriptedFaceWait( $npc_miller, $tgt_miller_facing, 0);
	
	aiScriptedAnim( $npc_miller, "ad_miller", 16, 0);

	// the wounded marine speaks
	sys.wait(6);
	aiSpeakWait( $npc_chase, "lipsync_vo_wounded_1");

	sys.wait(1.2);
	
	//miller calls for a medic
	aiSpeakWait( $npc_miller, "lipsync_1_1_1_170_2");
	sys.wait(1);

	//and we're all jammed...reprimands kovitch
	$npc_miller.lookAt( $npc_kovitch );
	aiSpeak( $npc_miller, "lipsync_1_1_1_170_3");
	sys.wait(2.4);
	while ( $npc_miller.isSpeaking( )) 
	{
		sys.waitFrame();
	}
	aiScriptedFace(	$npc_kovitch, $npc_miller, 0 );
	$npc_kovitch.lookAt( $npc_miller );
	sys.wait(0.5);
	// Kovitch responds and then tells player to get the medic from the level start
	aiSpeak( $npc_kovitch,  "lipsync_1_1_1_170_4");
	sys.wait(2);
	$npc_kovitch.lookAt( $player1 );
	sys.wait(0.5);
	$npc_miller.lookAt( $player1 );
	while ( $npc_kovitch.isSpeaking( )) 
	{
		sys.waitFrame();
	}

	sys.wait(0.6);

	//miller barks orders.
	aiSpeakWait( $npc_miller, "lipsync_1_1_1_180_1");
	sys.trigger( $objectiveMedic);
	
	$npc_miller.setTalkState( TALK_OK );

	//secretly, near the intro of the map, we move the medic indoors.
	$npc_redshirt_1.setWorldOrigin( $tgt_redshirt_waiting_here.getWorldOrigin());

	sys.killthread("injuredMarineLoop");
	$npc_anderson_outdoor.remove();

	//set anderson up for battle. This might work.
	$npc_anderson.setTalkState( TALK_OK );

	// set up level progression items.
	sys.trigger( $trigger_relay_getmedic );
	sys.trigger( $marine_skewer );
}

//------------------------------------------------------------------
// When player gets close to Miller, Miller gives orders to go get
//	the Anderson (the medic at the start of the map)
//------------------------------------------------------------------
void millerOrdersPlayerToGetMedic()	
{
	//miller gets up
//	aiScriptedAnimWait( $npc_miller, "knee_to_idle", 1, 1);
	aiScriptedFaceWait( $npc_miller, $player1, 1);

	//miller barks orders.
	aiSpeakWait( $npc_miller, "lipsync_1_1_1_180_1");
	sys.trigger( $objectiveMedic);
	
	$npc_miller.setTalkState( TALK_OK );

	//secretly, near the intro of the map, we move the medic indoors.
	$npc_redshirt_1.setWorldOrigin( $tgt_redshirt_waiting_here.getWorldOrigin());

	sys.killthread("injuredMarineLoop");
	$npc_anderson_outdoor.remove();

	//set anderson up for battle. This might work.
	$npc_anderson.setTalkState( TALK_OK );
}

//------------------------------------------------------------------
void kovitchUnlockDoor()
{
	sys.wait(2.4);

	$npc_kovitch.lookAt( $null_entity );
	aiScriptedFaceWait( $npc_kovitch, $tgt_kovitch_unlock_look, 0 );
	sys.wait(0.5);
	aiScriptedAnim( $npc_kovitch, "point_forward", 16, 0 );

	sys.wait(1.6);

	// unlock the doors here
	$door_medicRoom_1.lock(0);
	$door_medicRoom_2.lock(0);
	$door_medicRoom_1.setShaderParm(7,1);
	$cortez_door_locked.hide();
	$cortez_door_unlocked.show();
	sys.trigger( $speaker_core_heavy_unlock );

	sys.wait(1.8);

	aiScriptedFace( $npc_kovitch, $tgt_kovitch_post_unlock_look, 0 );
	$npc_kovitch.lookAt( $player1 );
}

//------------------------------------------------------------------
// fired when the medic is delivered to the injured marines in the level
//------------------------------------------------------------------
void medicDelivered()	
{
	// Prep kovitch to unlock the door
	aiScriptedMove( $npc_kovitch, $tgt_kovitch_here_1, 4, 0);
	aiScriptedMove( $npc_miller, $tgt_miller_here_next, 4, 0 );

	// turn off the medic's follow
	$npc_anderson.setLeader( $null_entity );
	$npc_anderson.setKey( "healer", "0");
	$npc_anderson.becomePassive( true );
	
	// face kovitch correclty and move the medic to his destination
	aiScriptedMove( $npc_anderson, $tgt_medic_here, 2, 0);
	aiScriptedWait( $npc_kovitch );
	aiScriptedFace( $npc_kovitch, $tgt_kovitch_post_unlock_look, 0 );
	aiScriptedWait( $npc_anderson );

	// change miller's talk info
	$npc_miller.setKey( "lipsync_talk_primary",	"vo_9_12_20_2");
	$npc_miller.setKey( "lipsync_talk_secondary", "vo_9_12_30_1");
	$npc_miller.setKey( "lipsync_talk_loop1",	"vo_9_12_30_3");

	//Miller	2_50_1		  
	aiSpeak( $npc_miller, "lipsync_1_1_2_50_1");
	aiScriptedFace( $npc_miller, $npc_chase, 0 ); 
	aiScriptedFace( $npc_kovitch, $npc_anderson, 0);
	aiScriptedMoveWait( $npc_anderson, $tgt_medic_heal, 2, 0);
	$npc_anderson.setOrigin( $tgt_medic_heal.getOrigin());

	// complete the objective
	sys.trigger( $completeObjectiveMedic);

	//Chase		20_50_2
	aiSpeak( $npc_chase, "lipsync_vo_wounded_2");

	aiScriptedAnim( $npc_anderson, "and_stimpack2a", 24, 0);
	aiScriptedAnim( $npc_chase, "and_stimpack2b", 24, 0 );

	sys.wait(2.75);

	// Anderson	20_50_3 pulls out a syringe
	aiSpeak( $npc_anderson, "lipsync_1_1_2_50_3");
	$npc_miller.lookAt( $npc_chase);
	aiScriptedFace( $npc_miller, $tgt_kovitch_post_unlock_look, 0 );
	
	sys.wait(11);

	// Anderson 20_50_4 puts syringe away
	aiSpeakWait( $npc_anderson, "lipsync_1_1_2_50_4");
	aiScriptedAnimLoop( $npc_anderson, "and_stimpack2a_loop", 4 );
	aiScriptedAnimLoop( $npc_chase, "and_stimpack2b_loop", 4 );

	// Miller 20_50_5 orders player away.
	sys.wait(.8);
	$npc_miller.lookAt( $player1 );
	aiSpeak( $npc_miller, "lipsync_1_1_2_50_5");
	sys.wait(1);
	$npc_miller.lookAt( $npc_kovitch );
	aiScriptedFace( $npc_miller, $door_medicRoom_1, 0 );
	sys.wait(1);
	aiScriptedAnim( $npc_miller, "point_forward", 4, 0);
	
	sys.wait(.25);
	$npc_miller.lookAt( $player1 );

	thread kovitchUnlockDoor();

	$npc_miller.becomePassive(true);
	$npc_anderson.becomePassive(true);
}

//---------------------------------------------------------------------------
// End of Badger / Medic Scenarios
//---------------------------------------------------------------------------


// this sets off the battle in the intro vista
void vistaHarvesterIntro()
{
//	sys.trigger( $vista_marine_1);
//	sys.trigger( $vista_marine_2);

	thread vistaHarvesterOne();
//	thread vistaHarvesterTwo();
}

void aiScriptedAnimRepeatWait( entity eEnt, string sAnim, float fBlend, float fEndIdle, float fReps )
{
	while ( fReps > 0 )
	{
		aiScriptedAnimWait( eEnt, sAnim, fBlend, fEndIdle );
		fReps--;
	}
}

void vistaHarvesterOne()
{
	sys.wait(10.5);
//	$walker_vista_1.show();
	aiScriptedAnim( $walker_vista_1, "vista_overlook", 1, 1);

	//attack the walker
	$monster_harvester_1.setAnimRate( 1.4 );
	aiScriptedAnimRepeatWait( $monster_harvester_1, "walk", 4, 0, 3 );
	$monster_harvester_1.setAnimRate( 1.2 );
	aiScriptedAnimRepeatWait( $monster_harvester_1, "walk", 4, 0, 3 );
	$monster_harvester_1.setAnimRate( 1 );

	aiScriptedAnimWait( $monster_harvester_1, "fire_forward_spray_start", 4, 0 );
	aiScriptedAnimWait( $monster_harvester_1, "fire_forward_spray_loop", 4, 0 );
	aiScriptedAnimWait( $monster_harvester_1, "fire_forward_spray_end", 4, 0 );

	aiScriptedAnimWait( $monster_harvester_1, "walk", 4, 0 );
	aiScriptedAnim( $monster_harvester_1, "attack_rleg_fw", 4, 0 );

	sys.wait(1);
	$death.directDamage( $walker_vista_1, "damage_gib");
	sys.wait(1);
	$monster_harvester_1.setAnimRate( 1.4 );
	aiScriptedAnimRepeatWait( $monster_harvester_1, "walk", 4, 0, 5 );
	
	$monster_harvester_1.remove();
}

void vistaHarvesterTwo()	
{
	//walk down the mountain
//	aiScriptedAnimWait( $monster_harvester_2, "walk_mountain", 1, 0);
//	$monster_harvester_2.remove();

}

//frame commands for the harvester attacking debris
void harvesterAttackDebris1()	{

	float t;
	for( t=4; t<=7; t++)	{
		entity ent = sys.getEntity("vista_debris_" + t);
		ent.applyImpulse( ent, ent.getWorldOrigin(), '8500000 -5000000 40000000');
	}
	sys.wait(0.1);
	sys.trigger( $fx_vista_debris_bustah );

	$vista_marine_1.becomeRagdoll();
	$vista_marine_2.becomeRagdoll();
	sys.waitFrame();
	$vista_marine_1.applyImpulse( $vista_marine_1, $vista_marine_1.getWorldOrigin(), '28000 9800 24000');
	$vista_marine_2.applyImpulse( $vista_marine_2, $vista_marine_2.getWorldOrigin(), '24000 9800 27000');
	sys.wait(4);
	$vista_marine_1.kill();
	$vista_marine_2.kill();
	

}

void harvesterAttackDebris2()	{

	float t;
	for( t=1; t<=3; t++)	{
		entity ent = sys.getEntity("vista_debris_" + t);
		ent.applyImpulse( ent, ent.getWorldOrigin(), '-8500000 -5000000 20000000');
	}

}

void harvesterAttackDebris3()	{
	$moveable_vista_truck.applyImpulse( $moveable_vista_truck, $tgt_truck_harvester_impact.getWorldOrigin(), '10000000 -8000000000 2000000000');
	
	aiScriptedMoveWait( $vista_vehicle_flatbed_1, $tgt_truck_dest, 4, 1);

}

// 43 - 123 - firing cannon (full auto or bursts - whatever looks good) at harvester - good accuracy, but the harvester barely feels it.
void vistaWalkerActions1()	{
	
	float fFrame = 0;
	float fCannon = 1;
	string strJoint;
	while(fFrame < 110)	{

		if( sys.random(100) < 10)
		{
			strJoint = "Cannon" + fCannon;
			walkerFireFromJoint( $walker_vista_1.getJointHandle(strJoint), $vista_fire_cannon );
			if( fCannon == 1)
				fCannon = 2;
			else
				fCannon = 1;
		}
		sys.waitFrame();
		fFrame++;
	}
}

// 166 - 197 - fire rockets salvo at harvester - harvester goes on guard to protect itself
void vistaWalkerActions2()	{
	
	sys.println("Walker2 begin");
	float fRocket = 1;
	while(fRocket < 7)	{

		string strJoint = "Rocket" + fRocket;
		walkerFireFromJoint( $walker_vista_1.getJointHandle(strJoint), $vista_fire_rocket );
		sys.wait(0.25);
		fRocket++;
	}
	sys.println("Walker2 end");

}

//firing cannons and / or rockets
void vistaWalkerActions3()	{
	
	sys.println("Walker3 begin");

	float fFrame = 0;
	float fRocket = 1;
	float fCannon = 1;
	string strJoint;

	while(fFrame < 77)	{

		if( sys.random(100) < 20)
		{
			strJoint = "Cannon" + fCannon;
			walkerFireFromJoint( $walker_vista_1.getJointHandle(strJoint), $vista_fire_cannon );
			if( fCannon == 1)
				fCannon = 2;
			else
				fCannon = 1;
		}
		else if( sys.random(100) < 5)
		{	
			strJoint = "Rocket" + fRocket;
			walkerFireFromJoint( $walker_vista_1.getJointHandle(strJoint), $vista_fire_rocket );
			sys.wait(0.25);
			fRocket++;
			if( fRocket == 7)
				fRocket = 1;
			sys.waitFrame();
		}
		
		fFrame++;
	}

	sys.println("Walker3 end");

}

void vistaWalkerActions4()	{

	//boom!
//	$death.directDamage( $walker_vista_1, "damage_gib");
	sys.println("not booming here");
	
}


//a marine gets stuck to the stabby arm of the harvester
void vistaGrabMarine()	{

	$vista_marine_fling.show();
//	sys.trigger( $vista_marine_fling);
	//$vista_marine_fling.becomeRagdoll();
	sys.waitFrame();

	//$vista_marine_fling.setKey("bindConstraint neckcontrol", "fixed");
	$vista_marine_fling.bind( $tgt_harvester_hoof);
}

void vistaThrowMarine()	{

	//fling the marine
	$vista_marine_fling.unbind();
	$vista_marine_fling.becomeRagdoll();
	sys.waitFrame();
	$vista_marine_fling.applyImpulse( $vista_marine_fling, $vista_marine_fling.getWorldOrigin(), '303880 70880 20000');

	//fire at the harvesters
	float t= 0;
	for( t = 0; t< 5; t++)	{
		sys.trigger($vista_tracer_1);
		sys.wait(0.25 + sys.random(1));
		sys.trigger($vista_tracer_2);
		sys.wait(0.25 + sys.random(1));
	}

	//kill off the marine
	$vista_marine_fling.kill();
	sys.wait(5);
}

//-------------------------------------------------------------
void doCortezBerserker()
{
	aiScriptedMoveWait( $cortez_berserker, $tgt_cortez_berserker_dest, 4, 0);
	aiScriptedAnim( $cortez_berserker, "leap_attack", 8, 1 );
}

void cortezIntro()	
{
	// move all strogg towards cortez...use some anims to spice it all up, no blend anims!
	// cortez gets fancy...
	$npc_cortez.setAngles( '0 0 0' ); // ensure facing
	aiScriptedAnim( $npc_cortez, "ad_cortez_intro", 0, 0);
	aiScriptedAnim( $strogg_cortez_1, "dive", 0, 1);
	aiScriptedAnim( $strogg_cortez_2, "nav_leap", 0, 1);
	thread doCortezBerserker();

	// Eric doesn't want him speaking during the 3 shot whiz bang
	sys.wait(3.5);
	
	aiSpeakWait( $npc_cortez, "lipsync_1_1_2_55_1");
	aiScriptedAnimLoop( $npc_anderson, "talk_idle", 24);

	sys.wait(1);
	$npc_cortez.lookAt( $player1 );

	aiSpeak( $npc_cortez, "lipsync_1_1_2_55_2");
	sys.wait(6.5);
	aiScriptedAnim( $npc_cortez, "point_right", 1, 1);
	
	$npc_cortez.setTalkState( TALK_OK ); // , "talk_idle");
	$npc_cortez.lookAt( $null_entity );
}

void _cortezVictim( entity victim, entity gibFx, vector impulse, string joint )
{
	vector vHead = victim.getJointPos( victim.getJointHandle( joint ));
	gibFx.setWorldOrigin(vHead);
	gibFx.setAngles( victim.getAngles() );
	gibFx.start();	
	victim.kill();
	sys.waitFrame();
	victim.applyImpulse( victim, vHead, impulse );
}
void cortezVictim1()	
{
	_cortezVictim( $strogg_cortez_1, $fx_death_gib, '0 -10000 10000', "forhead" );
}
void cortezVictim2()	
{
	_cortezVictim( $strogg_cortez_2, $fx_death_gib_1, '0 -10000 10000', "forhead" );
}
void cortezVictim3()	
{
	_cortezVictim( $cortez_berserker, $fx_death_gib, '0 -40000 40000', "head" );
}

// When the player returns to the combat room, he'll get some help.
void combatReinforcements()	{

	if( g_combatReinforcements == 1)
		return;

	g_combatReinforcements = 1;

	//lock the doors
	$door_intro_combat_1.lock(1);

	//wait a bit
	sys.wait(2);

	sys.println("Backup is here!");

	//send in anderson and the redshirt
	$door_intro_combat_1.lock(0);
	sys.waitFrame();

	aiScriptedTetherMove( $npc_redshirt_1, $tether_intro_reinforcement);

//	aiScriptedMoveWait( $npc_anderson, $tether_intro_reinforcement, 72, 1);
//	aiScriptedTetherMove( $npc_anderson, $tether_intro_reinforcement);
//	$npc_anderson.setLeader( $npc_redshirt_1);
	//sys.trigger( $tether_intro_reinforcement);
}

// towards the end of the map is a strogg on top of the trenches that jumps down and rushes the player.
//---------------------------------------------------
void stroggTrenchJumpDown()
{
	aiScriptedAnimWait( $strogg_jumpTrench, "shuffle_right", 8, 0 );
	aiScriptedAnim( $strogg_jumpTrench, "jump_trench", 8, 1 );
}

//---------------------------------------------------
void medicHealingCheck(entity entMedic)	
{
	entMedic.setKey("alive", "true");
	entMedic.setKey("healer","1");

	entity entEnemy; 
	
	//this is how many ticks without an enemy have gone by.
	float fEnemyTimer = 0;

	while( entMedic.getKey("alive") == "true" && entMedic.getKey("healer") == "1")	
	{
		// do I have any enemy already?
		entEnemy = entMedic.getEnemy();
		if ( !isValidEntity(entEnemy))
		{
			// ok, are there any enemies nearby?
			entEnemy = entMedic.findEnemy( (500*500));
		}
		if ( isValidEntity(entEnemy) || $player1.getHealth() > 35 || $player1.getHealth() <= 0 )	
		{
			fEnemyTimer = 0;
		}
		else 
		{
			fEnemyTimer++;
			if( fEnemyTimer >= 5 && g_andersonHealing == 0  && entMedic.distanceTo($player1) < 640 )	
			{
				// five seconds without an enemy around? Heal the player.
				sys.println("Healing the player.");
				medicHealPlayer( entMedic);
				fEnemyTimer = -5; // reset timer so another heal will happen no sooner than 10 seconds from now
			}
		}

		sys.wait(1);
	}
}

//------------------------------------------------------------
void medicHealPlayer(entity entMedic)	
{
	g_andersonHealing = 1;

	aiSpeak( entMedic, "lipsync_call_player_" + randomRoundFloat(1,4));

	//move near the player
	aiScriptedMoveWait( entMedic, $player1, 48, 0);
	aiScriptedFaceWait( entMedic, $player1, 0);
	entMedic.lookAt( $player1 );

	if ( isValidEntity(entMedic.findEnemy((500*500) )))
	{
		// um, probably not a good time to heal
		entMedic.lookAt( $null_entity );
		entMedic.becomeAggressive();

		g_andersonHealing = 0;		
		return;
	}

	aiSpeak( entMedic, "lipsync_heal_start_" + randomRoundFloat(1,4));

	// play the medic anim
	entMedic.setAnimRate( 1.3 );
	aiScriptedAnim( entMedic, "medic_treating_player", 8, 0);	

	sys.wait(0.5);
	$func_anderson_vaccinegun.show();
	sys.wait(1);

//	snd_med_gun_heal

	// Just use a target_give because it's easier..if we wanted to do the old incremental heal, we could still use a target_give
	sys.trigger( $target_heal_player );
	sys.wait(.75);
	aiScriptedAnim( entMedic, "medic_treating_player_end", 8, 1);	
	sys.wait(0.7);
	$func_anderson_vaccinegun.hide();
	sys.wait(1);
	entMedic.setAnimRate( 1 );

//	aiSpeak( entMedic, "lipsync_heal_end_" + randomRoundFloat(1,4));
	entMedic.lookAt( $null_entity );
	entMedic.becomeAggressive();

	g_andersonHealing = 0;
}

void trenchFlyerInRange()	{
	g_flyerInRange = 1;
}
void trenchFlyerOutRange()	{
	g_flyerInRange = 0;
}

//----------------------------------------------
void trenchFlyerShoot()
{
	float hnd = $strogg_flyer_trench_2.getJointHandle( "left_gun" );
	$tgt_flyergun_l.setWorldOrigin( $strogg_flyer_trench_2.getJointPos( hnd));
	$tgt_flyergun_l.setAngles( $strogg_flyer_trench_2.getJointAngle( hnd ));
	sys.trigger( $tgt_flyergun_l);

	hnd = $strogg_flyer_trench_2.getJointHandle( "right_gun" );
	$tgt_flyergun_r.setWorldOrigin( $strogg_flyer_trench_2.getJointPos( hnd));
	$tgt_flyergun_r.setAngles( $strogg_flyer_trench_2.getJointAngle( hnd ));
	sys.trigger( $tgt_flyergun_r);
}

//void prepareIntroParty()	{
//	$npc_redshirt_1.setLeader( $player1);
//}

// Medic anderson laments the dead bodies of his comrade
void andersonSadness()	
{
	// hack anderson to not heal right now
	g_andersonHealing = 1;
	$npc_anderson.lookAt( $env_ragdoll_marine_fullgear_2 );
	sys.wait(0.5);
	aiSpeak( $npc_anderson, "lipsync_vo_1_1_2_40_1");
	sys.wait(2);
	$npc_anderson.lookAt( $null_entity );
	g_andersonHealing = 0;
}


// Underwood rolls into the trench
void underwoodRoll()  
{
	aiScriptedAnimWait( $npc_underwood, "crouch_to_stand", 8, 0 );
	sys.trigger( $fx_underwood_bomb );
	aiScriptedAnimWait( $npc_underwood, "roll_trench", 4, 0);
	aiScriptedFace( $npc_underwood, $player1, 1);
	aiSpeakWait( $npc_underwood, "lipsync_vo_1_1_3_20_1");
	$npc_underwood.setLeader( $player1);

}

//walker_vista_1
void walkerFireFromJoint( float fJoint, entity entWeapon)	{
	
	vector vWeaponPos = $walker_vista_1.getJointPos( fJoint);
	vector vWeaponAng = sys.vecNormalize( sys.angToForward( $walker_vista_1.getJointAngle( fJoint)));
	
	entWeapon.setWorldOrigin( vWeaponPos);

	// make the weapon fire along the bone line, so move it's target out along the vector.	
	entity entTarget = entWeapon.getTarget(0);
	entTarget.setWorldOrigin( entWeapon.getWorldOrigin() + (vWeaponAng * 128));

	sys.trigger( entWeapon);

	if( isValidEntity( entWeapon.getTarget(1)))
		sys.trigger( entWeapon.getTarget(1));
	
}

//------------------------------------------------------------
void doAmbientIntroWalker()
{
	sys.wait(1);
	$aiDriver_1.enterVehicle( $vehicle_walker_1 );
	sys.wait(1);
	thread walkerShoot( $aiDriver_1, $vehicle_walker_1 );
	sys.wait(1);

	aiScriptedAnimWait( $vehicle_walker_1, "ad_intro_walker",0, 0 );
	aiScriptedAnimWait( $vehicle_walker_1, "ad_intro_walker",8, 0 );
	$aiDriver_1.exitVehicle(1);
	sys.waitFrame();
	$vehicle_walker_1.remove();
}

//------------------------------------------------------------
void levelStart()
{
	if(sys.getcvar("si_entityFilter") == "nocin")
	{
		sys.println("No cinematic!");
		return;
	}
	sys.println(" *** ");
	sys.println(" si_entityFilter == " + sys.getcvar("si_entityfilter"));
	sys.println(" *** ");

	sys.trigger($cin_opening);
//	sys.wait(0.25);
	sys.trigger( $func_fx_vision_blur );
	sys.fadeIn('0 0 0', 2 );

	thread doAmbientIntroWalker();
/*
	sys.wait(5);
	sys.fadeOut('0 0 0', 4 );
	sys.wait(4.5);
	sys.fadeIn('0 0 0', 8 );
*/
}

//frame 40						
//------------------------------------------------------------
void startCinAmbientMarines()
{
	aiScriptedAnim(	$ad_intro_char_marine_1, "ad_intro_run1", 0, 0 );
	aiScriptedAnim(	$ad_intro_char_marine_2, "ad_intro_run2", 0, 0 );
	aiScriptedAnim(	$ad_intro_char_marine_3, "ad_intro_run3", 0, 0 );
	aiScriptedAnim(	$ad_intro_char_marine_4, "ad_intro_run4", 0, 0 );
	aiScriptedAnim(	$ad_intro_char_marine_5, "ad_intro_getup", 0, 0 );
/*	sys.trigger( $ad_intro_char_marine_1 );
	sys.println( "1" );
	sys.trigger( $ad_intro_char_marine_2 );
	sys.println( "2" );
	sys.trigger( $ad_intro_char_marine_3 );
	sys.println( "3" );
	sys.trigger( $ad_intro_char_marine_4 );
	sys.println( "4" );
	sys.trigger( $ad_intro_char_marine_5 );
	sys.println( "5" );
*/
}
//frame 155
//------------------------------------------------------------
void cinGetUpVO()
{
	aiSpeak( $ad_intro_char_marine_5, "lipsync_vo_1_1_0_01_22" );
	$ad_intro_char_marine_1.remove();
	$ad_intro_char_marine_2.remove();
	$ad_intro_char_marine_3.remove();
	$ad_intro_char_marine_4.remove();
}
//frame 160
//------------------------------------------------------------
void cinNailed()
{
	sys.trigger( $speaker_nailed_1 );
	sys.wait(.15);
	sys.trigger( $speaker_nailed_2 );
	sys.wait(.15);
	sys.trigger( $speaker_nailed_3 );
}

//frame 247
//------------------------------------------------------------
void instantCinBlackout()
{
	sys.fadeOut('0 0 0', .1 );
}
//frame 328
//------------------------------------------------------------
void cinFadeBackIn()
{
	sys.fadeIn('0 0 0', 2 );
}

void main()	
{
	//turn off the trench tracers
	thread deactivateTrenchTracers(0, 24);
	thread andersonDragsMedic();

	//set Morris up
	thread morrisIntroLoop();

	//strogg vs marine airpower go!
	entity entFlyer;
	float t;
	
	//originally, there were six planes per side. Now we're using 2, and that might change too. But the
	//+6 for the 3rd parameter is because originally the damaged versions of the sprites started at 7.

	for (t = 1; t <= 2; t++)	{
		thread maintainStroggFlyerSprite( sys.getEntity("mvr_fx_strogg_flyer_" + t), sys.getEntity("fx_air_strogg_fighter_" + t), sys.getEntity("fx_air_strogg_fighter_" + (t + 6) ), $tgt_strogg_flyer_hangar, $tgr_strogg_flyer_end, '-1 0 .1' );
		thread maintainStroggFlyerSprite( sys.getEntity("mvr_fx_marine_flyer_" + t), sys.getEntity("fx_air_marine_fighter_" + t), sys.getEntity("fx_air_marine_fighter_" + (t + 6) ), $tgt_marine_flyer_hangar, $tgr_marine_flyer_end, '1 0 .1' );
	}

	//wounded marines out front-- this will also be Anderson's speech.
	thread injuredMarineLoop( $npc_metcalf, $npc_anderson_outdoor);
	
	$npc_metcalf.disableHeal();


	//guy impaled in metal
//	thread introMarineShishkabob();
	
	thread vistaHarvesterIntro();

	// started from here - see NOTE in startTrenchCombat as to why
	thread maintainBigGun();

	thread levelStart();

}


/*
	sounds:

	(Trench Ambient) 
		radio VO: sound vo_1_1_3_70_1
		Walkers advancing: vo_1_1_3_30_1
		I need a medic!: 1_1_3_10_1
	
	(person asploding)
		"The trench! Finally I've made it to irony!!": sound vo_1_1_3_50_1
	
	(ambient radio chatter)
		1_1_2_02_1
		1_1_2_04_1
		1_1_2_06_1
	

	
*/



}	//end namespace