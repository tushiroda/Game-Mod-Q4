//-----------------------------------------------------------------------
// Scripts for Core level
//
// Chad Bordwell
// Jim Shepard
// Chuck Nicholson
//
// May 2004
// Mar 2005
// (c) Raven Software
//-----------------------------------------------------------------------

#include "scripts/doom_defs.script"

namespace map_core
{

//---------------------------------------------------------------------------------------
//  Global variables

/*
	setMoveType back to fly to stop a unit from running a playback.

	g_recordplayerinfo  1: from feet
						2: wall surface?
						3: from eyes

	$object.runPlayback(
*/

#define			STOPPED 0
#define			GOING_UP 1
#define			GOING_DOWN 2

float g_fPlatformState = STOPPED;

//introductory teleport sequence happens right at player spawn
void introTeleport();

//---------------------------------------------------------------------------------------
//	#core_probe
//	The probulation room, complete with verification arm, lights and real-action sounds!
// 
//	Jim Shepard | May 04

//fired after the elevator reaches the bottom with the player inside. 
void beginProbing();

//activates the lights in the Probe Room
void ProbeRoomLightsOn();

//activates the alarm lights/sound in the ProbeRoom
void ProbeAlarm();

//sounds the alarm and sends in the troops
void probeAlarmAttack();

//binds the elevator doors to the elevator
void bindDoorsToElevator();

//---------------------------------------------------------------------------------------
//	#core_glowroom
//	A room with cool glowpasses and tubes that a repair bot fixes. 
// 
//	Jim Shepard | May 04

//loop that keeps the panels all buzzing and happy, with the repair bot cleaning them up.
void panelLoop();

//handlers for the panel loop (so that panelLoop can be made into a thread we can kill via script.)
void beginPanelLoop();
void endPanelLoop();

//this is a copy of andrew's moveToJump util script but added an enemy key near the end to force the jumping strogg to attack the player -corey
void moveToJumpMainCore( entity imJumping )	{

	// To use: Create a target_null at the spot where the jump will commence. Set the "angle" key
	// to the desired value. When targeting the monster, specify the "moveToJump" function in script_init.
	// That function will thread this function and, ideally, allow multiple guys to run this concurrently.
	// Target the target_null from the monster (and make sure it is the first target).
	// The monster will perform a scripted move to the jump point and jump at the specified angle
	// declared in the target_null.
	
	// If necessary, add a "radius" key to the target null with the desired scriptedMove radius.
	// This is best used in situations where a monster may have trouble reaching the exact point (i.e. 
	// a jump starting from terrain).
	
	// The monster will also become passive at the start of the function and become aggressive at the end.
	// This is in an attempt to keep guys from getting stuck in the jump cycle.
	
	// Declare variables for actions
	entity jumpFrom = imJumping.getTarget(0);
	float jumpDirection = jumpFrom.getFloatKey( "angle" );
	float radius = jumpFrom.getFloatKey( "radius" );
	
	// Become passive.
	imJumping.becomePassive(1);
	
	// Move to jump position
	if( isLivingEntity( imJumping ) )	{
		aiScriptedMoveWait( imJumping , jumpFrom , radius, 0 );
	}
		
	// Jump and become aggressive
	if( isLivingEntity( imJumping ) )	{
		imJumping.scriptedJumpDown( jumpDirection );
		imJumping.becomeAggressive();
		imJumping.setEnemy($player1);
	}	
}

// Thread this for when many guys are doing it.
void moveToJumpCore( entity imJumping )	{
	thread 	moveToJumpMainCore( imJumping );
}


void introTeleport()
{
	$player1.disableWeapon();
	sys.waitFrame();
	sys.trigger($teleportIntroFOV); //set_influence fov twister
	sys.fadeIn('1 1 1', 1.25);
	sys.wait(3);
	$player1.enableWeapon();
}

void ObjectiveDestroyNexus()
{
	sys.wait(18); // wait for strauss' vo to finish
	sys.trigger($item_objective_destroy_nexus);
}

// Locks first set of doors in the level.
void LockFrontDoor()
{
	$func_door_entry_r.setShaderParm( 7, 0);
	$func_door_entry_r.lock(2);
	$func_door_entry_l.lock(2);
}

//opens up the Probedoor
void openProbedoor()	{
	
	//sys.println("Opening bigdoor");
	sys.trigger( $funcdoor_bigprobedoor);
	sys.wait(15);
	//sys.println("Closing bigdoor");
	sys.trigger( $funcdoor_bigprobedoor);
}

void removeShake()
{
	if (isValidEntity($speaker_10))	{
		$speaker_10.remove(); //doors close, remove wind sound
	}

	// after the doors have closed, shut off the shake and other fx
	if (isValidEntity($func_fx_hill_smoke))
		$func_fx_hill_smoke.remove();
	if (isValidEntity($func_fx_bury));	
		$func_fx_bury.remove();	
}

void AnimateMakron()
{
	// Play Makron's animation
	aiScriptedAnimWait($monster_makron_verification, "verification_monitor", 0, true );
	aiScriptedAnimLoop($monster_makron_verification, "verification_monitor_idle", 1) ;
}

//new probe sequence -cpeters
void beginProbing()
{
	
	//turn on the lights
	ProbeRoomLightsOn();

	thread AnimateMakron();
	
	playAnimWait($env_verification_arm_1, ANIMCHANNEL_ALL, "probe_start");
	$env_verification_arm_1.playCycle(ANIMCHANNEL_ALL, "probe_loop" );
		
	sys.wait(1);
	
	$mvr_probe_laser_1.setColor(1,0,0);
	sys.trigger($probeScan_fx_1);
	sys.trigger($speaker_probe_lasersound_on_1);
	sys.trigger($speaker_probe_lasersound_loop);
	sys.trigger($lgt_ElevatorBooth); //turn off booth light
	sys.trigger($light_probeLasers); //turn on fill light
	$light_probeLasers.setCurrentLightLevel(1);
	
	sys.wait(.2);
	
	$mvr_probe_laser_2.setColor(1,0,0);
	sys.trigger($probeScan_fx_2);
	$mvr_probe_laser_3.setColor(1,0,0);
	sys.trigger($probeScan_fx_3);
	sys.trigger($speaker_probe_lasersound_on_2);
	$light_probeLasers.setCurrentLightLevel(2);
	
	sys.wait(.2);
	
	$mvr_probe_laser_4.setColor(1,0,0);
	sys.trigger($probeScan_fx_4);
	$mvr_probe_laser_5.setColor(1,0,0);
	sys.trigger($probeScan_fx_5);
	sys.trigger($speaker_probe_lasersound_on_3);
	$light_probeLasers.setCurrentLightLevel(3);
	
	sys.wait(1);
	
	$func_mover_scanner_1.move(180,92);
	sys.trigger($speaker_probe_lasersound_complete);
	sys.waitFor($func_mover_scanner_1);
	$func_mover_scanner_1.move(0,92);
	sys.waitFor($func_mover_scanner_1);
			
	//turn it off
	$mvr_probe_laser_4.setColor(0,0,0);
	sys.trigger($probeScan_fx_4);
	$mvr_probe_laser_5.setColor(0,0,0);
	sys.trigger($probeScan_fx_5);
	sys.trigger($speaker_probe_lasersound_off_1);
	sys.trigger($speaker_probe_lasersound_loop);
	$light_probeLasers.setCurrentLightLevel(3);

	sys.wait(.2);
	
	$mvr_probe_laser_2.setColor(0,0,0);
	sys.trigger($probeScan_fx_2);
	$mvr_probe_laser_3.setColor(0,0,0);
	sys.trigger($probeScan_fx_3);
	sys.trigger($speaker_probe_lasersound_off_2);
	$light_probeLasers.setCurrentLightLevel(2);
	
	sys.wait(.2);

	$mvr_probe_laser_1.setColor(0,0,0);
	sys.trigger($probeScan_fx_1);
	sys.trigger($speaker_probe_lasersound_off_3);
	sys.trigger($light_probeLasers); //turn off fill light
	$light_probeLasers.setCurrentLightLevel(0);
	sys.trigger($lgt_ElevatorBooth); //turn on booth light
	
	//monsters attack
	thread probeAlarmAttack();
	
	sys.wait(0.25);
	$env_verification_arm_1.playAnim(ANIMCHANNEL_ALL, "probe_end" );
	
	//wait a bit
	sys.wait(4);
}

//after the player has been probed, he will be detected as a hybrid entity and attacked.
void probeAlarmAttack()
{
	//turn on the alarm lights and play the alarm sound
	ProbeAlarm();

	//sentient voice
	sys.trigger($Speaker_ProbeSentient_1);

	sys.wait(2);
	
	//give objective
	sys.trigger($item_objective_shutdownsecurity);

	//alarm noise
	sys.trigger($speaker_ProbeAlarm);

	//open the doors so the baddies can rush in
	$probedoor1a.open();
	$probedoor1b.open();
    $probedoor2a.open();
	$probedoor2b.open();

	sys.waitFrame();
	sys.trigger($relay_probeAlarmAttack);

	sys.wait(4);
	
	//$monster_gladiator_5.becomeAggressive(); //removed to allow ai_radius to check gladiators position before going active.
	$monster_tactical_blaster_1.becomeAggressive();
	$monster_tactical_blaster_2.becomeAggressive();

	//kick open the doors
	$Controller_ElevatorBackDoor_rotate1.time(5);
	$Controller_ElevatorBackDoor_rotate1.rotateOnce('0 0 90');

	$Controller_ElevatorFrontDoor_rotate1.time(5);
	$Controller_ElevatorFrontDoor_rotate1.rotateOnce('0 0 -90');

	sys.waitFor($Controller_ElevatorBackDoor_rotate1);

	sys.trigger($speaker_Elevator1Door_Stop);
	
	//close the doors
	$probedoor2a.close();
	$probedoor2b.close();
	$probedoor1a.close();
	$probedoor1b.close();

	//lock them, the player needs to exit through the exploded floor hole.
	$probedoor2a.lock(1);
	$probedoor2b.lock(1);
	$probedoor1a.lock(1);
	$probedoor1b.lock(1);

	sys.trigger($Speaker_ProbeSentient_2);
	
	//give objective
	//sys.trigger($item_objective_shutdownsecurity);
}

void unlockSecurityDoors()	{

	//unlock the doors and change their color to green
	$probedoor1a.setShaderParm( 7, 1);
	$probedoor2a.setShaderParm( 7, 1);
	

	//turn off the siren lights
	$light_red_boothwarn_1.fadeOutLight(0.5);
	$light_red_boothwarn_2.fadeOutLight(0.5);
	sys.wait(0.5);

	//return lights to normal
	thread ProbeRoomLightsOn();
	
	//trigger guis to indicate alarm is off
	$func_static_13705.guiEvent("trigger");
	
	//turn off alarm
	sys.trigger($speaker_ProbeAlarm);
	
	//complete objective
	sys.trigger($item_objectivecomplete_shutdownsecurity);
}

// new summonMaiden script -cpeters
void summonMaiden()
{
	//blow out floor
	sys.trigger($func_fx_probeFloorExp_1);
	sys.trigger($speaker_floorexplosionadd_1); //extra explosion sounds
	sys.trigger($moveable_probefloorgrate_1);
	
	//let iron maiden out
	sys.trigger($func_static_54163);
	
	sys.wait(0.4);
	
	//static on the monitor
	sys.trigger($probe_room_monitor_1);
	sys.trigger($probe_room_monitor_2);	
	
	sys.trigger($func_fx_probeFloorExp_2);
	sys.trigger($func_fx_probeFloorScreenSpark_2);
	sys.trigger($moveable_probefloorgrate_2);
	
	sys.wait(0.25);
	sys.trigger($func_fx_probeFloorExp_3);
	sys.trigger($speaker_floorexplosionadd_2); //extra explosion sounds
	sys.trigger($func_fx_probeFloorScreenSpark_1);
	sys.trigger($moveable_probefloorgrate_3);
	sys.trigger($moveable_probefloorgrate_4);
	
	sys.wait(0.05);
	sys.trigger($moveable_probefloorgrate_5);
	sys.trigger($moveable_probefloorgrate_6);

	//remove grates before they interfere with the maiden
	sys.wait(.25);
	$moveable_probefloorgrate_1.remove();
	
	sys.wait(0.05);
	$moveable_probefloorgrate_2.remove();
	$moveable_probefloorgrate_3.remove();
	
	sys.wait(0.1);
	$moveable_probefloorgrate_4.remove();
	$moveable_probefloorgrate_5.remove();
	$moveable_probefloorgrate_6.remove();
	
	//bring in iron maiden
	sys.trigger($speaker_maidensurprise);
	sys.trigger($monster_iron_maiden_probe_surprise);
}

//------------------------------------------------------------------
// void ProbeRoomLightsOff	
//
// Dims the lights in the Probe Room
//
// Jim Shepard
//------------------------------------------------------------------
void ProbeRoomLightsOff()
{
	//Dim the lights in the probe room.
	$light_ProbeRoom_FarEast.setColor(.1, .1, .1);		//Originally (0.54, 0.65, 0.79)
	$light_ProbeRoom_E2.setColor(.1, .1, .1);		//Originally (0.14, 0.16, 0.2)
	$light_ProbeRoom_FarWest.setColor(.1, .1, .1);		//Originally (0.54, 0.65, 0.79)
	$light_ProbeRoom_S1.setColor(.1, .1, .1);		//Originally (0.26, 0.31, 0.38)
	$light_ElevatorBottom.setColor(.7,.1,.1);		//.7, .1, .1

	$light_ProbeRoom_Floor1.setColor(0, 0, 0);		//Originally (0.08, 0.07, 0.05)
	$light_ProbeRoom_Ceiling1.setColor(0, 0, 0);	//Originally (0.32, 0.39, 0.47)

}

//------------------------------------------------------------------
// void ProbeAlarm
//
// Activates the alarm lights in the Probe Room
//
// Jim Shepard
// ripped out all the chicklit lights, do not colour shift these. -corey
//------------------------------------------------------------------
void ProbeAlarm()
{	// Change the lights in the probulation room after the character is probed.

	//Set lights to red test color-
	sys.trigger($speaker_ProbeRoom_LightsOn);
	$light_ProbeRoom_FarWest.setColor(0.88, 0.01, 0);
	$light_ProbeRoom_FarEast.setColor(0.88, 0.01, 0);
	$func_static_4498.setColor(0.88, 0.01, 0); //light model
	$func_static_14791.setColor(0.88, 0.01, 0); //associated patch
	$func_static_4497.setColor(0.88, 0.01, 0); //light model
	$func_static_14792.setColor(0.88, 0.01, 0); //associated patch
	$light_ElevatorBottom.setColor(0.88, 0.01, 0);
		
	$light_red_boothwarn_1.On();
	$light_red_boothwarn_2.On();
}
//------------------------------------------------------------------
// void ProbeRoomLightsOn
//
// Flickers the probe lights on, plays an activation sound as well.
//
// Jim Shepard
//------------------------------------------------------------------
void ProbeRoomLightsOn()
{
	//Init variables
	float	flickercount;
	flickercount = 0;

	//Flicker the lights on in the probe room.
	while(flickercount < 6)
	{
		// Lights at half
		$light_ProbeRoom_FarEast.setColor(0.54, 0.65, 0.79);
		$light_ProbeRoom_FarWest.setColor(0.54, 0.65, 0.79);
		$func_static_4498.setColor(0.54, 0.65, 0.79); //light model
		$func_static_14791.setColor(0.54, 0.65, 0.79); //associated patch
		$func_static_4497.setColor(0.54, 0.65, 0.79); //light model
		$func_static_14792.setColor(0.54, 0.65, 0.79); //associated patch
		$light_ElevatorBottom.setColor(0.54, 0.65, 0.79);
		sys.wait(.025);

		// Lights dimmed
		$light_ProbeRoom_FarEast.setColor(.2, .2, .2);
		$light_ProbeRoom_FarWest.setColor(.2, .2, .2);
		$func_static_4498.setColor(.2, .2, .2); //light model
		$func_static_14791.setColor(.2, .2, .2); //associated patch
		$func_static_4497.setColor(.2, .2, .2); //light model
		$func_static_14792.setColor(.2, .2, .2); //associated patch
		$light_ElevatorBottom.setColor(.2, .2, .2);
		
		sys.wait(.025);
		flickercount ++;
	}

	//Final light colors
	sys.trigger($speaker_ProbeRoom_LightsOn);
	$light_ProbeRoom_FarWest.setColor(0.65, 0.8, 0.96);
	$light_ProbeRoom_FarEast.setColor(0.65, 0.8, 0.96);
	$func_static_4498.setColor(0.65, 0.8, 0.96); //light model
	$func_static_14791.setColor(0.65, 0.8, 0.96); //associated patch
	$func_static_4497.setColor(0.65, 0.8, 0.96); //light model
	$func_static_14792.setColor(0.65, 0.8, 0.96); //associated patch
	$light_ElevatorBottom.setColor(0.37, 0.45, 0.54);

}


//------------------------------------------------------------------
// void ChangeElevator1TopLights()
//
// Activates the elevator when the button is pressed. Creates some
// cool spark effects was well.
//
// Jim Shepard
//------------------------------------------------------------------
void ChangeElevator1TopLights()
{

	//Set lights temporarily to near-black
	$light_ElevatorTop_Console1.setColor(.1, .1, .1);
	$light_ElevatorTop_left.Off();//(.1, .1, .1);
	$light_ElevatorTop_right.Off();//setColor(.1, .1, .1);
	$light_ElevatorTop_front.Off();//setColor(.1, .1, .1);

	//Trigger lights and FX for electrical arcs
	sys.trigger($func_fx_ElevatorSparks_1);
	sys.trigger($func_fx_ElevatorSparks_2);
	sys.trigger($func_fx_ElevatorSparks_3);
	sys.trigger($func_fx_ElevatorSparks_4);
	sys.trigger($func_fx_ElevatorSparks_5);

	sys.wait(2);

	//Bring lights back on as more orange-ish
	crossFadeEnt($light_ElevatorTop_Console1,'.1 .1 .1','.75 .7 .5',2);
	$light_ElevatorTop_Warning.show();

	//Trigger warning sound for elevator moving
	sys.trigger($speaker_Elevator1_MovementWarning);

	
}

//------------------------------------------------------------------
//void PlatformLights(float r, float g, float b)
//Changes the color of all the lights on the platform floor
//------------------------------------------------------------------

void PlatformLights(float r, float g, float b)
{
	// Needs to fade from one color to the other 4/26/05 gc

	float fadeTime = .25; // number of seconds that it takes to switch the colors
	float increments = 30; // the number of times the light color will change over the course of the switch
	float timestep = fadeTime/increments; // the amount of time between color changes

    vector oldRGB = $platform_1_light_7889.getColor(); // all of the lights should be the same color

	// determine how much each color value should change per loop
	float deltaR = (r - oldRGB_x) / increments;
	float deltaG = (g - oldRGB_y) / increments;
	float deltaB = (b - oldRGB_z) / increments;

	// start at the old light color
    r = oldRGB_x;
	g = oldRGB_y;
	b = oldRGB_z;

	while (increments > 0)
	{
		increments--;
		sys.wait(timestep);

		// update the light color
		r += deltaR;
		g += deltaG;
		b += deltaB;
		
		// change the lights

		$platform_1_light_7889.setColor(r, g, b);
		$platform_1_light_7890.setColor(r, g, b);
		$platform_1_light_7891.setColor(r, g, b);
		$platform_1_light_7892.setColor(r, g, b);
		$platform_1_light_7893.setColor(r, g, b);
		$platform_1_light_7894.setColor(r, g, b);
		$platform_1_light_6382.setColor(r, g, b); //added this -corey
		$platform_1_light_7895.setColor(r, g, b); //added this -corey
	}
}

//------------------------------------------------------------------
//void MovePlatform1(float fDirection)
//
// Moves Platform1 Up or Down depending on fDirection (UP or DOWN)
// or Stops the platform if already moving in that direction.
//
// g_fPlatformState is a global float that holds the current platform state (GOING_UP, GOING_DOWN, STOPPED)
//
//------------------------------------------------------------------

void MovePlatform1(entity entSelf)
{	
	// The platform has 2 buttons, UP and DOWN.
	// Pressing UP will move the platform UP, 
	//   unless its already moving up, in which case platform1 stops.
	// Pressing DOWN will move the platform DOWN,
	//   unless its already moving down, in which case platform1 stops.
	// The platform will only move within its RANGE. Range is a null
	// target used to limit the mover's position. These targets are:
	// platform_1_max_height
	// platform_1_min_height
	//
	// The Platform CALL buttons work the same way.
	//
	// GUI Notes: In order to properly display the correct GUIs, a GuiEvent must be sent to the appropriate guiObject.
	// Use the following command to do that: [$]EntityName.guiEvent("state");
	// For example, the Platform CALL button's name is platform_1_gui_call_up. Thus, $platform_1_gui_call_up.guiEvent("moveDone");
	// Possible key values are "moving", "paused", and "moveDone"
	//  "moving" is for when the platform is currently moving
	//	"paused" is for when the platform is not moving, but still can move (Not at top or bottom)
	//  "moveDone" is for when the platform has completed its entire move. This will disable the GUI.
	
	#define PLATFORM_MOVE_SIZE 8		// This determines how many units the platform moves at a time.
	
	// Since we can't pass params via entity call, I had to pass in the entire entity using triggerwithself = 1
	// The relay trigger should have a key value called fDirection that specifies which direction to move the
	// platform (UP = -1, DOWN = -2)
	float fDirection = entSelf.getFloatKey("fDirection");	
		
	vector vecPlatform1 = $platform_1.getWorldOrigin();
	vector vecPlatform1MaxHeight = $platform_1_max_height.getWorldOrigin();	// This null target determines the maximum height the platform can go
	vector vecPlatform1MinHeight = $platform_1_min_height.getWorldOrigin(); // This null target determines theminimum height the platform can go
			
	if (UP == fDirection)
	{
		//jshepard
		//if (GOING_UP == g_fPlatformState)	// If platform is already going up,
		//{
		//	g_fPlatformState = STOPPED;		// then pressing UP again stops it.
		//	thread PlatformLights(1, 1, 1);
		//	$platform_1_gui_call_up.guiEvent("paused");
		//	$platform_1_gui_activate.guiEvent("paused");
		//}
		//else
		//{
			g_fPlatformState = GOING_UP;	// Otherwise, go up
			thread PlatformLights(.75, 0, 0);
			$platform_1_gui_call_up.guiEvent("moving");
			$platform_1_gui_activate.guiEvent("moving");
		//}	
		while (GOING_UP == g_fPlatformState)
		{
			if (vecPlatform1_z < vecPlatform1MaxHeight_z)		// If platform isn't at max height
			{
				// OK, since the platform moves PLATFORM_MOVE_SIZE at a time, we have to ensure its
				// within the platform's allowable bounds.
				if ((vecPlatform1MaxHeight_z - vecPlatform1_z) < PLATFORM_MOVE_SIZE)
					$platform_1.move( UP, vecPlatform1MaxHeight_z - vecPlatform1_z);
				else
					$platform_1.move( UP, PLATFORM_MOVE_SIZE);
			}
			else
			{
				g_fPlatformState = STOPPED;						// Once maxed, don't move it.
				thread PlatformLights(1, 1, 1);
				$platform_1_gui_call_up.guiEvent("moveDone");
				$platform_1_gui_activate.guiEvent("paused");
			}
				
			sys.waitFrame();
			vecPlatform1 = $platform_1.getWorldOrigin();		// Update platform position
		}
		
	}
	else if (DOWN == fDirection)
	{
		//jshepard: no.
		//if (GOING_DOWN == g_fPlatformState)	// If platform is already going down,
		//{
		//	g_fPlatformState = STOPPED;		// then pressing DOWN again stops it.
		//	thread PlatformLights(1, 1, 1);
		//	$platform_1_gui_call_up.guiEvent("paused");
		//	$platform_1_gui_activate.guiEvent("paused");
		//}
		//else
		//{
			g_fPlatformState = GOING_DOWN;	// Otherwise, go down
			thread PlatformLights(.75, 0, 0);
			
			//added this, no need to interact any more.
			$platform_1_gui_activate.setGuiParm("noninteractive", "1");
			
			//keep the player on the lift
			sys.trigger($func_static_playercliplift);
			$platform_1_gui_call_up.guiEvent("moving");
			$platform_1_gui_activate.guiEvent("moving");
		//}
		
		while (GOING_DOWN == g_fPlatformState)
		{
			if (vecPlatform1_z > vecPlatform1MinHeight_z)			// If platform isn't at min height
			{	
				// OK, since the platform moves PLATFORM_MOVE_SIZE at a time, we have to ensure its
				// within the platform's allowable bounds.
				if ((vecPlatform1_z - vecPlatform1MinHeight_z) < PLATFORM_MOVE_SIZE)
					$platform_1.move( DOWN, vecPlatform1_z - vecPlatform1MinHeight_z);	// then move it. 
				else
					$platform_1.move( DOWN, PLATFORM_MOVE_SIZE);
			}
			else
			{
				g_fPlatformState = STOPPED;							// Once maxed, don't move it.
				thread PlatformLights(1, 1, 1);
				$platform_1_gui_activate.guiEvent("moveDone");
			}
			
			sys.waitFrame();
			vecPlatform1 = $platform_1.getWorldOrigin();			// Update platform position
		}
	}
}


//------------------------------------------------------------------
// void CallProbeElevator()
//
// Called when player pushed the Call GUI button.
// This function is responisble for bringing the Probe Elevator to the top floor where the player can enter it.
// The elevator will follow a series of Path Nodes, 1 at a time, named elevator_probe_path_# (# is an integer>0).
// (1) Turn on the siren light
// (2) Spawn a monster in the elevator shaft
// (3) Make the enemy come up from the bottom of the shaft to engage the player
// (4) Move the elevator along the path nodes, from lowest path node# to the highest, 1 at a time.
// (5) Open Front Probe Elevator Door.
//
// Chuck Nicholson (based upon work done by Jim Shepard)
//------------------------------------------------------------------

void CallProbeElevator()
{
	float index = 1;

	// (1) Turn on the probe elevator siren lights
	//$light_booth_called.On();
/* - removed these two steps, doing it through entities. -corey
	// (2) Spawn a monster in the elevator shaft
	sys.trigger($monster_sentry_2);
	
	// (3) Make the enemy come up from the bottom of the shaft to engage the player
	if (isValidEntity($monster_sentry_2))
		aiScriptedMove($monster_sentry_2, $light_ElevatorTop_front, 2 , 1 );
*/
	//	if (isValidEntity(botName))		// Face the panel
		//aiScriptedFaceWait( botName, entPanel, 0 );

	// (4) Move along path nodes, from lowest path node# to the highest, 1 at a time.
	// Go to each path node that exists
	entity entPath = sys.getEntity("elevator_probe_path_" + index);

	while (isValidEntity(entPath))
	{
		//sys.println("Found valid ProbeElevator Pathnode : " + entPath.getName() + " at " + entPath.getWorldOrigin());

		$Controller_ElevatorBooth_mover1.moveTo(entPath);
		sys.waitFor($Controller_ElevatorBooth_mover1);
		sys.wait(1);
		index+=1;
		entPath = sys.getEntity("elevator_probe_path_" + index);
	}

	// (5) Open Front Probe Elevator Door.
	// Now that we're out of path nodes, we must be at the end, so open the doors
	//sys.trigger($speaker_Elevator1Door_Move);
	//sys.println("Opening Probe Elevator Door");
	$Controller_ElevatorFrontDoor_rotate1.time(1);
	$Controller_ElevatorFrontDoor_rotate1.rotateOnce('0 0 -90');
	
	sys.waitFor($Controller_ElevatorFrontDoor_rotate1);
	//sys.trigger($speaker_Elevator1Door_Stop);
	//sys.println("Done Opening Probe elevator door");

	//turn on the inside elevator light
	$lgt_ElevatorBooth.On();
}

//------------------------------------------------------------------
// void DescendProbeElevator()
//
// Called when the player enters the Probe Elevator.
// The elevator will follow the reverse series of Path Nodes, 1 at a time, 
// named elevator_probe_path_# (# is an integer>0).
// (1) Close the Probe Elevator Door.
// (1a) Setup Makron's custom monitor idle animation
// (2) Descend back to starting position using a reverse-path node algorithm.
// (3) Once at the end, the player is probed.
//
// Chuck Nicholson (based upon work done by Jim Shepard)
//------------------------------------------------------------------
void DescendProbeElevator()
{

	// (1) Close the Probe Elevator Door.
	//sys.println("(1) Close the Probe Elevator Door.");
	$Controller_ElevatorFrontDoor_rotate1.rotateOnce('0 0 90');
	sys.waitFor($Controller_ElevatorFrontDoor_rotate1);

	// At some point we want to setup the Makron with his custom monitor animation, so this is a good spot.
	// (1a) Setup Makron's custom monitor idle animation
	aiScriptedAnimLoop($monster_makron_verification, "verification_monitor_idle", 1);

	float index = 1;
	
	// Go to each path node that exists
	entity entPath = sys.getEntity("elevator_probe_path_" + index);

	// Find the last path node
	while (isValidEntity(entPath))
	{
		//sys.print("    Node#" + index); 
		index+=1;
		entPath = sys.getEntity("elevator_probe_path_" + index);
	}

	//sys.println(" ");
	// Skip the last node (Since elevator is already at the last node)
	index -=1;
	entPath = sys.getEntity("elevator_probe_path_" + index);

	// Move the Probe elevator in reverse order of the path nodes
	while (isValidEntity(entPath))
	{
		//sys.println("Found valid reverse ProbeElevator Pathnode : " + entPath.getName() + " at " + entPath.getWorldOrigin());

		$Controller_ElevatorBooth_mover1.moveTo(entPath);
		sys.waitFor($Controller_ElevatorBooth_mover1);
		sys.wait(1);
		index-=1;
		entPath = sys.getEntity("elevator_probe_path_" + index);
	}

	//start the probe room sequence
	thread  beginProbing();
}

void CallElevator1()
{	//Function called when GUI is used. Brings elevator to upper level, opens door.

	//sys.println("CallElevator1::begin");
	//Change lights in room at top of elevator shaft
	thread	ChangeElevator1TopLights();
	thread	ProbeRoomLightsOff();


	//Retract elevator booth (at bottom)
	$Controller_ElevatorBooth_mover1.speed(200);//should be 50
	$Controller_ElevatorBooth_mover1.moveTo($Path_Elevator1_ShaftBottom);

	sys.waitFor($Controller_ElevatorBooth_mover1);
	sys.wait(2);

	//Go up the shaft
	$Controller_ElevatorBooth_mover1.speed(200);//should be 80
	$Controller_ElevatorBooth_mover1.moveTo($Path_Elevator1_ShaftTop);
	sys.trigger($speaker_Elevator1_StartNoise);
			    
	sys.waitFor($Controller_ElevatorBooth_mover1);
	
	sys.wait(1);
	
	//Turn on booth light
	$light_Elevator1_booth.show();

	//chill out with the sparks
	$func_fx_ElevatorSparks_1.remove();
	$func_fx_ElevatorSparks_2.remove();
	$func_fx_ElevatorSparks_3.remove();
	$func_fx_ElevatorSparks_4.remove();
	$func_fx_ElevatorSparks_5.remove();
	
	//Extend elevator booth
	// keep -- sys.trigger($speaker_Elevator1Booth_StartNoise);
	//sys.println("Booth_start");
	$Controller_ElevatorBooth_mover1.speed(50);
	$Controller_ElevatorBooth_mover1.moveTo($Path_ElevatorBooth_ExtendedTop);

	sys.wait(.1);

	//sys.println("Booth_move");
	sys.waitFor($Controller_ElevatorBooth_mover1);
	
	sys.trigger($speaker_Elevator1Booth_StopNoise);

	sys.wait(1);

	//Open door at top
	sys.trigger($speaker_Elevator1Door_Move);
	//sys.println("Door_open");
	$Controller_ElevatorFrontDoor_rotate1.time(1);
	$Controller_ElevatorFrontDoor_rotate1.rotateOnce('0 0 -90');
	
	sys.waitFor($Controller_ElevatorFrontDoor_rotate1);
	
	sys.trigger($speaker_Elevator1Door_Stop);
	//sys.println("Door_stop");

	//turn on the inside elevator light
	$lgt_ElevatorBooth.On();

}
//------------------------------------------------------------------
// void CloseElevator1()
//
// Closes the Elevator and sends it down to the probe room.
//------------------------------------------------------------------
void CloseElevator1()
{	//Function called after the character enters the elevator. Closes door and takes character to lower level.

	//sys.println("CloseElevator1::begin");
	//Close door at top
	$Controller_ElevatorFrontDoor_rotate1.time(1);
	$Controller_ElevatorFrontDoor_rotate1.rotateOnce('0 0 90');
	sys.trigger($speaker_Elevator1Door_Move);
	//sys.println("Door_move");
	
	sys.waitFor($Controller_ElevatorFrontDoor_rotate1);
	
	//keep-- sys.trigger($speaker_Elevator1Door_Stop);
	//sys.println("Door_stop");

	//Retract elevator booth (at top)
	$Controller_ElevatorBooth_mover1.speed(50);
	$Controller_ElevatorBooth_mover1.moveTo($Path_Elevator1_ShaftTop);
	//sys.trigger($speaker_Elevator1Booth_MoveNoise);
	//sys.println("Booth_Move");
	//sys.trigger($speaker_Elevator1_MovementWarning);

	sys.waitFor($Controller_ElevatorBooth_mover1);
	
	//sys.trigger($speaker_Elevator1Booth_MoveNoise);
	//sys.println("Booth_Move");
	//keep-- sys.trigger($speaker_Elevator1Booth_StopNoise);
	//sys.println("Booth_stop");
		
	sys.wait(1);

	//Go down the shaft
	$Controller_ElevatorBooth_mover1.speed(80);
	$Controller_ElevatorBooth_mover1.moveTo($Path_Elevator1_ShaftBottom);
	//keep-- sys.trigger($speaker_Elevator1_StartNoise);
	//sys.println("Elevator_start");

	sys.waitFor($Controller_ElevatorBooth_mover1);
	
	//keep-- sys.trigger($speaker_Elevator1Booth_StopNoise);
		//sys.println("Booth_stop");
	//keep-- sys.trigger($func_fx_Elevator1_TopVent_3);
	//keep-- sys.trigger($func_fx_Elevator1_TopVent_4);
	//keep-- sys.trigger($speaker_Elevator1Vents_SteamNoise_2);
		//sys.println("Elevator_steam2");
	
	sys.wait(1);

	//Turn off warning sound at top of the elevator shaft
//	sys.trigger($speaker_Elevator1_MovementWarning);

	//Extend elevator booth (at bottom)
	$Controller_ElevatorBooth_mover1.speed(30);
	$Controller_ElevatorBooth_mover1.moveTo($Path_ElevatorBooth_ExtendedBottom);

	sys.wait(.1);

	sys.waitFor($Controller_ElevatorBooth_mover1);
		
	//start the probe room sequence
	thread  beginProbing();

}

//------------------------------------------------------------------
// void assembleProbeElevator()
//
// Binds together the probe elevator.
//
// Jim Shepard
//------------------------------------------------------------------
void assembleProbeElevator()
{
	//move the controller into place

	//bind the booth to the controller
	$func_mover_Elevator1_Booth.bind($Controller_ElevatorBooth_mover1);
	
	//bind the doors.
	bindDoorsToElevator();

	CallProbeElevator();
}
void bindDoorsToElevator()
{
	//this is a "lock" which binds the door rotators to the elevator, 
	//so that when the elevator moves the doors come along.
	$Controller_ElevatorBackDoor_rotate1.bind($Controller_ElevatorBooth_mover1);
	$Controller_ElevatorFrontDoor_rotate1.bind($Controller_ElevatorBooth_mover1);
}

//teleport spawner
//infinite teleporter in core1
void teleportSpinnerActivate()
{
	$func_rotating_1.rotate('0 40 0');
}

void teleport_effect()
{
	sys.trigger($target_setinfluence_teleporterroom);
	sys.waitFrame();
}

//-----------------------------------------------------------------------
// void kill_teleport_effect
// jshepard | May 04
//
// Removes the teleporter from the map once the last bad guy is spawned
// cnicholson, Added VO 3_2_1_57_1 about teleporting being severed
//-----------------------------------------------------------------------

void kill_teleport_effect()
{
	//called the function
	//sys.println("kill_teleport_effect::begin");

	// Play the sentient VO for severing the Teleporter
	sys.trigger($speaker_severed);

	//this is the teleporter effect
	$func_fx_8.remove();

	//this is the spawner
	$func_spawner_enemy_light_2.remove();

	//sys.println("kill_teleport_effect::end");

}

//-----------------------------------------------------------------------
//Calling Elevator   -Chad
//-----------------------------------------------------------------------
void move_elevator()
{
	$func_elevator_1.gotoFloor(3);
}

//----------------------------------------------------
//	void panelLoop() 
//
//	This function randomly selects a panel from a grid of twelve,
//  opens it, and has a repair bot fly around and nurture it.
//
//  jShepard
//----------------------------------------------------
void panelLoop()
{
	//return;

	//entity that represents the current panel we're moving
	entity currentPanel;

	//floats for the x and y position of the panel
	float panelX = 1;
	float panelY = 1;

	//vector for the panel's location in world space
	vector vecPanelLoc;

	//floats for the previous panel position, so we don't do the same one twice:
	float oldPanelX = -1;
	float oldPanelY = -1;

	//first, put the repair bot in his place
	$mon_glow_repair.activate($mon_glow_repair);
	//sys.println("Moving repair bot to home destination...");
	$mon_glow_repair.setWorldOrigin($tgt_repair_home.getWorldOrigin());
	$mon_glow_repair.setAngles('0 180 0');
	$fx_repair_spark.hide();


	//note: I chumped it up, X values go from 1 to 3.
	while(1)
	{
		//get initial x and y values
		while( (panelX == oldPanelX) && (panelY == oldPanelY) )
		{
			float x = sys.random(30);
			float y = sys.random(40);

			//hack hack hack: there has GOT to be a better way to do this!!
			if(x < 10)
				panelX = 1;
			else if(x < 20)
				panelX = 2;
			else
				panelX = 3;

			//hack hack hack: there has GOT to be a better way to do this!!
			if(y < 10)
				panelY = 0;
			else if(y < 20)
				panelY = 1;
			else if(y < 30)
				panelY = 2;
			else
				panelY = 3;

			sys.wait(0.01);

		};

		//set the oldPanels to the current values
		oldPanelX = panelX;
		oldPanelY = panelY;

		//now that we have x and y values, we can use that to place our cool glowy panel.
		currentPanel = sys.getEntity("mvr_panel_" + panelX + "_" + panelY);
		//sys.println("Getting mvr_panel_" + panelX + "_" + panelY);

		//we have it now! Move our cool panel into place
		$mvr_datapanel_1.setWorldOrigin(currentPanel.getWorldOrigin());

		//hide the current panel, show ours, and prepare to move
		currentPanel.hide();
		$mvr_datapanel_1.show();
		vecPanelLoc = $mvr_datapanel_1.getWorldOrigin();	
		
		sys.waitFrame();

		//sys.println("Moving repair bot to front-of-panel destination...");
		//move the repair bot to the location

	
		$mon_glow_repair.setWorldOrigin($tgt_repair_dest.getWorldOrigin());

		//bind the repairbot to the panel
		$mon_glow_repair.bind($mvr_datapanel_1);

		//now to move the panel out some.
		vecPanelLoc_x += 150;
		$mvr_datapanel_1.time(3);
		$mvr_datapanel_1.moveToPos(vecPanelLoc);
		$mon_glow_repair.setAngles('0 180 0');
		sys.waitFor($mvr_datapanel_1);
		
		$mon_glow_repair.unbind();
		aiScriptedFaceWait ( $mon_glow_repair, $mvr_datapanel_1, true );
		//$mon_glow_repair.setAngles('0 180 0');

		//do repair bot movement here-- top panels use playback 2...
		$fx_repair_spark.show();
		if(panelY == 0)
		{
			aiScriptedPlaybackMoveWait ( $mon_glow_repair, "playback_2", PLAYBACKFL_MOVE_RELATIVE|PLAYBACKFL_ANG_RELATIVE, 0 );
		}
		else
		{
			aiScriptedPlaybackMoveWait ( $mon_glow_repair, "playback_1", PLAYBACKFL_MOVE_RELATIVE|PLAYBACKFL_ANG_RELATIVE, 0 );
		}
		
		$fx_repair_spark.show();

		//bind the repairbot to the panel
		$mon_glow_repair.bind($mvr_datapanel_1);
	
		//move the panel back
		vecPanelLoc_x -= 150;
		$mvr_datapanel_1.moveToPos(vecPanelLoc);
		sys.waitFor($mvr_datapanel_1);

		//show the current panel
		currentPanel.show();

		//unbind the repair bot
		$mon_glow_repair.unbind();

		//that should be it.
		//sys.println("Cha cha cha! On to next panel~");

		//move him home

	};

}

void beginPanelLoop()
{
	thread panelLoop();
}

void endPanelLoop()
{
	sys.killthread("panelLoop");
}

//----------------------------------------------------
//	void TubeOut(entity botName, entity entPanel)
//
//	Has the repair bot 'pull' out the datatube
//----------------------------------------------------
void TubeOut(entity botName, entity entPanel)
{
	//sys.print("_Entered TubeOut__________________");
	//sys.println(" botName =" + botName.getName());
	//sys.println("   entPanel is " + entPanel.getName());

	// Get the out position null entity and move panel to it.
	entity entOutPos = entPanel.getTarget(0);

	if (isValidEntity(botName))		// Face the panel
		aiScriptedFaceWait( botName, entPanel, 0 );

	if (isValidEntity(botName))	// Bind bot to panel, if bot is still alive
	{
		botName.bind(entPanel);
		entPanel.moveTo(entOutPos);
	
		sys.waitFor( entPanel);	// Wait until the panel finishes moving before continuing.

		// mark the panel as out in case this bot dies.  This will allow us to notify a newly
		//	spawned bot to come in and finish partially finished jobs.
		entPanel.setKey( "inProgress", "1" );
	}

	if (isValidEntity(botName))			// Unbind bot from panel, if bot is still alive
        botName.unbind();
}

//----------------------------------------------------
//	void TubeIn(entity botName, entity entPanel)
//
//	Has the repair bot 'push' the datatube back in
//----------------------------------------------------
void TubeIn(entity botName, entity entPanel)
{
	//sys.print("_Entered TubeIn_______________");
	//sys.println("botName =" + botName.getName());
	//sys.println("    entPanel = " + entPanel.getName());
	
	if (!isValidEntity(entPanel))
	{
		//sys.println("Panel entity not found: " + entPanel.getName() + ". Cannot move tube back in");
		return;
	}

	// Get the in positional null entity and move panel to it.
	entity entInPos = entPanel.getTarget(1);

	if (!isValidEntity(entInPos))
	{
		//sys.println("Invalid entity: " + entInPos.getName() + ". Cannot move the tube back in");
		return;
	}

	if (isValidEntity(botName))		// Face the panel
		aiScriptedFaceWait( botName, entPanel, 0 );

	if (isValidEntity(botName))		// Bind bot to panel, if bot is still alive
	{
		botName.bind(entPanel);
		entPanel.moveTo(entInPos);
	
		sys.waitFor(entPanel);			// Wait until the panel finishes moving before continuing.

		// mark the panel as complete so that a bot doesn't think this tube is in a partially finished state
		entPanel.setKey( "inProgress", "0" );
	}

	// Get the shader that's on the datatube.
	entity entPanelTubeShader = entPanel.getEntityKey("tubename");
	entity entLight = sys.getEntity(entPanelTubeShader.getName() + "_light");
	if (!isValidEntity(entLight))
		sys.println("Invalid Light Entry. Verify " + entPanel.getName() + "_light exists." );
	else
		entLight.fadeOutLight(0.1);		// Turn off the light to save electricity
	
	if (isValidEntity(botName))			// Unbind bot from panel, if bot is still alive
        botName.unbind();
}

//--
// Repair Bot ambience 		aweldon Feb 05
//--

// Variation of Repair Bot script from hub2


void MakeTubeLightsCorrupt(entity entTubeShader)
//----------------------------------------------------
//	void MakeTubeLightsCorrupt(entity botName, entity entPanel)
//
// Makes the data tube (shader) a diferent color to represent corrupt data that the repair bot needs to fix
// We also turn on and fade the tube's light.
//----------------------------------------------------
{
	if (isValidEntity(entTubeShader))
	{
		//entity entTubeShader = entPanel.getEntityKey("tubename");
		//if (!(isValidEntity ( entTubeShader )))
		//{
		//	sys.println("Invalid data tube for " + entPanel.getName() + ".  Check for valid tubename key");
		//	return;
		//}
		entity entLight = sys.getEntity(entTubeShader.getName() + "_light");
		if (!isValidEntity(entLight))
		{
			//sys.println("Invalid Light Entry. Verify " + entTubeShader.getName() + "_light exists." );
			return;
		}
	}
	vector vecCorruptColor  = '1 0.5 0.0';	// Corrupt datatube color
    vector vecFixedColor = '0 0 1';		// Pure datatube color
	
	//sys.println("---Crossfading " + entTubeShader.getName());
	thread crossFadeEnt(entTubeShader, vecFixedColor, vecCorruptColor, 0.1);
	thread crossFadeEnt(entLight, vecFixedColor, vecCorruptColor, 0.1);
	sys.wait(0.1);
	entLight.fadeInLight(1.0);	// Turn on the light for this tube
}

void MakeTubeLightsFixed(entity entTubeShader)
//----------------------------------------------------
//	void MakeTubeLightsFixed(entity botName, entity entPanel)
//
// Makes the data tube (shader) fade to another color to represent the bot fixing it
// We also turn on and fade the tube's light.
//----------------------------------------------------
{
	if (isValidEntity(entTubeShader))
	{
		entity entLight = sys.getEntity(entTubeShader.getName() + "_light");
		if (!isValidEntity(entLight))
		{
			//sys.println("Invalid Light Entry. Verify " + entTubeShader.getName() + "_light exists." );
			return;
		}
	}
	
	vector vecCorruptColor  = '1 0.5 0.0';	// Corrupt datatube color
    vector vecFixedColor = '0 0 1';		// Pure datatube color

	//sys.println("---Crossfading " + entTube.getName());
	thread crossFadeEnt(entTubeShader, vecCorruptColor, vecFixedColor, 12);
	thread crossFadeEnt(entLight, vecCorruptColor, vecFixedColor, 12);
}					

// cnicholson
// Ok, this function controls the main Repair bot stuff for core.
// A Bot spawner is responsible for spawning a new bot. Each bot has its own list of targets
// As long as the bot lives, it does the following loop
// (1) The bot chooses a random, but valid panel to repair
// (2) Move to the front of panel
// (3) Pull out the panel
// (4) Move around to the side of the tube
// (5) Repair the tube
// (6) Go back around to the front of the panel
// (7) Push the panel back in
//
// Note: We have to verify the bot exists before each time we use it in case player kills the bot
// Each tube needs a null entity IN and OUT position to know how far in and out to move the tube.
// The OUT position needs to be target 0 of the panel
// The IN  position needs to be target 1 of the panel

void botActions( entity botName )
{
	// Define the entities that will be used for random target selection
	entity newTarget = $null_entity;	// This is the positional NULL object, NOT the panel itself.
	entity oldTarget = $null_entity;	// Used so the bot doesn't choose the same panel twice in a row
	entity entPanel;
	float doingUnfinishedJob = 0;

	// Pull the name of the correct list passed to this repair bot from the spawner.
	if( isValidEntity ( botName ) )
		entity botList = botName.getEntityKey("list");
	
	// Perform these actions as long as the Repair Bot lives.
	while ( isValidEntity( botName ) && botName.getHealth() > 0) 
	{
		// Always try to complete an in-process tube that is not occupied.
		//	This will happen if a bot pulls the tube out, but then is destroyed.
		doingUnfinishedJob = 0;
		float index;																	
		for( index = 0; $null_entity != (newTarget = botList.getTarget(index)); index++ )
		{
			entPanel = newTarget.getTarget(0);
			if ( newTarget.getKey( "occupied" ) == "0" && entPanel.getKey( "inProgress") == "1" )
			{
				doingUnfinishedJob = 1;
				break;
			}
		}

		if ( !doingUnfinishedJob )
		{
			// Select an initial place for the bot to move to at random from the list of target_nulls
			if( isValidEntity ( botName ) )
				newTarget = qListRandom( botList );

			// Don't currently have a target, so try to get a new one..don't choose a repeated or already-occupied target
			while ( newTarget.getKey( "occupied" ) == "1"  || newTarget == oldTarget)	
			{
				//sys.println("Found repeated/occupied Target, re-setting.");
				newTarget = qListRandom( botList );
				//sys.println("(1) Found new target: " + newTarget.getName());
				sys.waitFrame();
			}
		}

		// Keep track of previous target so we dont choose it again next time
		oldTarget = newTarget;	

		// Get the Panel that the repairTarget is pointing to
		entPanel = newTarget.getTarget(0);

		// Get the shader that's on the datatube.
		entity entPanelTubeShader = entPanel.getEntityKey("tubename");

		// Get the spot where the bot is supposed to move to in order to repair the tube
		entity entRepairSpot = sys.getEntity(newTarget.getName() + "b");

		// Set target as occupied to prevent other repair bots from using it
		newTarget.setKey( "occupied", "1");

		// Move to the target
		if(isValidEntity (botName)) {
            aiScriptedMoveWait( botName, newTarget, 4, 1 );
		}

		// In the event of an unfinished job, we skip a lot of the tasks and just have a newly spawned bot
		//	push the tube back in.  this was done to avoid adding lots of extra logic to make them 'smart'

		// Run check to ensure bot is still valid...if doing an unfinished job, this should not be done again
		if(isValidEntity(botName) && !doingUnfinishedJob) {	
			// Look at the panel.
			aiScriptedFaceWait( botName, entPanel, 1);

			// Change the color of the tube to represent its corruption prior to pulling it
			MakeTubeLightsCorrupt(entPanelTubeShader); 
			sys.waitFrame();
		}
		
		// (2) Move the bot to the front of the panel...if doing an unfinished job, this should not be done again
		if( isValidEntity( botName ) && !doingUnfinishedJob) {
			//sys.println("(2) Moving bot to new target: " + newTarget.getName());
			aiScriptedMoveWait( botName, newTarget, 4, 0 );
		}

		// Bot AI movement usually doesnt work for vertical/Z checks, so recheck....if doing an unfinished job, this should not be done again
		if( isValidEntity( botName ) && !doingUnfinishedJob )
		{
			if (botName.distanceTo(newTarget) > 8)
				aiScriptedMoveWait( botName, newTarget, 4, 1 );
			sys.wait(1);
		}	
		
		if( isValidEntity( botName ) && !doingUnfinishedJob ) {
			if (botName.distanceTo(newTarget) > 8) {
				//sys.println("  Bot is being stupid, cant move to locale. Too far away: " + botName.distanceTo(newTarget));
				continue;
			}
		}

		// (3) Pull out the Datatube/Panel....if doing an unfinished job, this should not be done again
		if( isValidEntity( botName ) && !doingUnfinishedJob ) {
			//sys.println("(3) __Pulling out the datatube__");
			TubeOut(botName, entPanel);
		}

		// (4) Move repair bot from front of panel (repair target) to repair spot
		if( isValidEntity( botName ) && !doingUnfinishedJob ) {
			botName.unbind();
			sys.waitFrame();
			//sys.println("(4) Moving bot to repair at repairspot: " + entRepairSpot.getName());
			aiScriptedMoveWait( botName, entRepairSpot, 4, 0 );
		}

		// Look at the target.
		if( isValidEntity( botName ) && !doingUnfinishedJob && botName.getHealth()>0 ) {
			//sys.println("Looking at target: " + entPanelTubeShader.getName());
			aiScriptedFaceWait( botName, entPanelTubeShader, 0 );
		}

		// (5) Repair the tube. (Show color change and bot laser animations)
		if( isValidEntity( botName ) && !doingUnfinishedJob && botName.getHealth()>0 ) {
			// Start the lighting effect that shows the bot is repairing the tube.
			MakeTubeLightsFixed(entPanelTubeShader);

			//sys.println("(5) Repairing target: " + entPanelTubeShader.getName());
			// Have the bot begin repairs
			aiScriptedActionWait( botName, entPanelTubeShader, 0 );
		}

		// Allow the rest of the tasks to be completed if doing an unfinished job.
		//	This may mean that the tube was not fixed, but it avoids extra tracking logic.

		// (6) Go back around to the front of the panel
		if( isValidEntity( botName ) && botName.getHealth()>0 ) {
			//sys.println("(6) Moving back around to front of panel");
			aiScriptedMoveWait( botName, newTarget , 4, 0 );
		}

		// (7) Push the panel back in
		if( isValidEntity( botName ) && botName.getHealth()>0 ) {
			//sys.println("(7) Pushing tube back in");
			TubeIn(botName, entPanel);
		}
		newTarget.setKey( "occupied", "0");
	}
}	

// This is the hallway repair bot, seperate from the normal repair bot since no datatubes are involed.
// A Bot spawner is responsible for spawning a new bot. Each bot has its own list of targets
// As long as the bot lives, it does the following loop
// (1) The bot chooses a random, but valid repair spot
// (2) Move to the repair spot
// (3) Face the direction targeted by the repair spot
// (4) Begin repairs (flashy lasers, wow!). May include spark fx at this locale.
//
// Note: We have to verify the bot exists before each time we use it in case player kills the bot
void hallwayBotActions( entity botName )
{
	//sys.println("hallwayBotActions called. Botname is " + botName.getName());

	// Define the entities that will be used for random target selection
	entity newTarget = $null_entity;	// This is the positional NULL object, NOT the panel itself.
	entity oldTarget = $null_entity;	// Used so the bot doesn't choose the same panel twice in a row
	
	// Pull the name of the correct list passed to this repair bot from the spawner.
	if( isValidEntity ( botName ) )
		entity botList = botName.getEntityKey("list");	// Note the actual keyname is "spawn_list". weird.
	
	// Select an initial place for the bot to move to at random from the list of target_nulls
	if( isValidEntity ( botName ) )
		newTarget = qListRandom( botList );
		
	// Perform these actions as long as the Repair Bot lives.
	while ( isValidEntity ( botName ) ) 
	{
		// Don't choose the same target twice
		while ( newTarget == oldTarget)	
		{
			//sys.println("Found repeated/occupied Target, re-setting.");
			newTarget = qListRandom( botList );
			//sys.println("(1) Found new target: " + newTarget.getName());
			sys.waitFrame();
		}

		// Keep track of previous target so we dont choose it again next time
		oldTarget = newTarget;	

		// Move to the target
		//sys.println("Moving to target: " + newTarget.getName());
		aiScriptedMoveWait( botName, newTarget , 2 , 1 );
		
		sys.wait(0.5);

		// Run check to ensure bot is still valid.
		if( isValidEntity ( botName ) )	
		{		
			// Face the direction that the repair spot targets
			//sys.println("Facing the target");
			aiScriptedFaceWait( botName, newTarget.getTarget(0), 1);
		}

		sys.wait(0.5);

		// Do the repairs
		if( isValidEntity ( botName ) )	
		{
			//sys.println("Beginnning Repairs on " + newTarget.getTarget(0).getName());
			aiScriptedActionWait( botName, newTarget.getTarget(0), 0 );
		}
		
		sys.wait(2);
	}
}	

void tubeBots( entity repairBot )	{

	thread botActions( repairBot );
}

void hallwayBot( entity repairBot )
{
	//sys.println("hallwayBot called. Botname is " + repairBot.getName());
	thread hallwayBotActions( repairBot );
}
//--
// End Repair Bot ambience
//--

//----------------------------------------------------
//	void ToggleForceFields(entity entSelf)
//
// This will toggle any force fields that are targetd by entSelf
// Note that the target relay must target force fields, and only force fields, and
// that the force fields must be in numerical sequence target, target1, target2, etc.
//
//  cnicholson
//----------------------------------------------------
void ToggleForceFields(entity entSelf)
{
	//sys.println("Entered ForceField toggle, entSelf is " + entSelf.getName());
	$func_forcefield_4.Toggle();
	$func_forcefield_1.remove();
	$light_8000.remove();

	//float index = 0;							// Keep track of which force field to toggle
	//entity entTarget = entSelf.getTarget(index);// Get first force field

	//while (isValidEntity(entTarget))
	//{
	//	entTarget.Toggle();						// Toggle the force field
	//	//if (entTarget.isHidden())				// If force field is already off, show it, else hide it
	//	//	entTarget.show();
	//	//else
	//	//	entTarget.hide();
	//	index +=1;
	//	entTarget = entSelf.getTarget(index);	// Get next force field
	//}
}

void OpenBigDoors()
//doors start closed, open them fast before the player notices
{
	$controller_coredoor_left_1_9.time(.1);
	$controller_coredoor_left_2_8.time(.1);
	$controller_coredoor_left_3_7.time(.1);
	$controller_coredoor_left_4_6.time(.1);
	$controller_coredoor_left_5.time(.1);
	
	$controller_coredoor_right_1_9.time(.1);
	$controller_coredoor_right_2_8.time(.1);
	$controller_coredoor_right_3_7.time(.1);
	$controller_coredoor_right_4_6.time(.1);
	$controller_coredoor_right_5.time(.1);
		
	$controller_coredoor_left_1_9.rotateOnce('0 -45 0');
	$controller_coredoor_left_2_8.rotateOnce('0 -45 0');
	$controller_coredoor_left_3_7.rotateOnce('0 -45 0');
    $controller_coredoor_left_4_6.rotateOnce('0 -45 0');
	$controller_coredoor_left_5.rotateOnce('0 -45 0');

	$controller_coredoor_right_1_9.rotateOnce('0 45 0');
	$controller_coredoor_right_2_8.rotateOnce('0 45 0');
	$controller_coredoor_right_3_7.rotateOnce('0 45 0');
	$controller_coredoor_right_4_6.rotateOnce('0 45 0');
	$controller_coredoor_right_5.rotateOnce('0 45 0');

	sys.wait(.5);
}

void retractSpires()	{
	$mvr_spire.time(10);
	$mvr_spire.move( NORTH, 1200);

}

void CloseBigDoors()
{
	thread retractSpires();

	$controller_coredoor_left_1_9.time(15);
	$controller_coredoor_left_2_8.time(15);
	$controller_coredoor_left_3_7.time(15);
	$controller_coredoor_left_4_6.time(15);
	$controller_coredoor_left_5.time(15);
	
	$controller_coredoor_right_1_9.time(15);
	$controller_coredoor_right_2_8.time(15);
	$controller_coredoor_right_3_7.time(15);
	$controller_coredoor_right_4_6.time(15);
	$controller_coredoor_right_5.time(15);

	$controller_coredoor_left_1_9.rotateOnce('0 45 0');
	$controller_coredoor_right_1_9.rotateOnce('0 -45 0');
	sys.wait(1.5);

	$controller_coredoor_left_2_8.rotateOnce('0 45 0');
	$controller_coredoor_right_2_8.rotateOnce('0 -45 0');
    sys.wait(1.5);
	
	$controller_coredoor_left_3_7.rotateOnce('0 45 0');
	$controller_coredoor_right_3_7.rotateOnce('0 -45 0');
	sys.wait(1.5);

	$controller_coredoor_left_4_6.rotateOnce('0 45 0');
	$controller_coredoor_right_4_6.rotateOnce('0 -45 0');
	sys.wait(1.5);

	$controller_coredoor_left_5.rotateOnce('0 45 0');
	$controller_coredoor_right_5.rotateOnce('0 -45 0');

	sys.waitFor($controller_coredoor_left_1_9);
	sys.trigger($speaker_coredoor_1);
	sys.waitFor($controller_coredoor_left_2_8);
	sys.trigger($speaker_coredoor_2);
	sys.waitFor($controller_coredoor_left_3_7);
	sys.trigger($speaker_coredoor_3);
	sys.waitFor($controller_coredoor_left_4_6);
	sys.trigger($speaker_coredoor_4);
	sys.waitFor($controller_coredoor_right_5);
	sys.trigger($speaker_coredoor_5);
	
	// Get rid of some of the outside fx once the doors are closed
	thread removeShake(); 
}
void brainGooDelay()	{

	sys.wait(6.5);
	$relay_braingoo_3.remove();
/*
	sys.trigger( $relay_braingoo_1 );
	sys.wait(1);
	sys.trigger( $relay_braingoo_2 );
*/

}
void playEndingCinematic()
{
	//set up the lights on kane for the end shots
	//sys.println("Cin Lights On ");
	sys.trigger ($kane_glory_orange);
	sys.trigger ($kane_glory_fill);
	
	// fades the normal room lights out
	sys.trigger ($kane_glory_lights_dim);

	// braingoo
	sys.trigger( $relay_braingoo_3 );
	thread brainGooDelay();

	//cameras
	playCameraWait($cam_gameEnd_1);
	playCameraWait($cam_gameEnd_2);
	sys.trigger($endGame);
}	

void cinFadein()
{
	sys.fadeIn('0 0 0', 1.5 );
	
}
void cinFadein2()
{
	sys.fadeIn('0 0 0', 1.5 );
	
}
void cinFadein3()
{
	sys.fadeIn('0 0 0', .1 );
	
}
void cinFadeout()
{
	sys.fadeOut('0 0 0', 1.5 );
	
}
void cinFadeout2()
{
	sys.fadeOut('0 0 0', 1.5 );
	
}

void cinFadeout3()
{
	sys.fadeOut('0 0 0', 2 );
	
}

// ----------------------------------------------------------------------
// Ending Cinematic Functions
// ----------------------------------------------------------------------

// Kane
// finale-- walking away from dead brain
void playFinale()	{
	sys.trigger( $speaker_music_4);
//	$speaker_music_3.remove();
}

//quiets the music when harper says "Kane, you have new orders."
//removing speaker 4 turns off the already-quiet music, then it turns the volume up so the end music can play.
void quietMusic()	{

	$speaker_music_4.remove();
	sys.trigger( $tgt_fademusic_in );
}

void animateKane_kain_idle() 
{
	//sys.println("animateKane_kain_idle");
	sys.trigger($npc_kane);
	aiScriptedAnim($npc_kane, "kain_idle", 1, 0);
	$npc_kane.hideSurface("models/weapons/mp_guns/w_mg_lo");
	sys.wait(4);
	//sys.println("Quieting down the music");
	sys.trigger( $tgt_fademusic_out_slow );
}

void kaneIdle()
{
	thread animateKane_kain_idle();
}

void animateKane_kain_glory()
{
	aiScriptedAnim($npc_kane_1, "kain_glory", 1, 0);
}

// Rhodes
void animateRhodes_rhodes_idle()
{
	aiScriptedAnim($npc_rhodes, "rhodes_idle", 1, 0) ;

}

// Sledge
void animateSledge_sledge_idle()
{
	aiScriptedAnim($npc_sledge, "sledge_idle", 1, 0) ;
}

// Morris
void animateMorris_morris_idle()
{
	aiScriptedAnim($npc_morris, "morris_idle", 1, 0) ;
}

// Cortez
void animateCortez_cortez_idle()
{
	aiScriptedAnim($npc_cortez, "cortez_idle", 1, 0) ;
}

// Strauss
void animateStrauss_strauss_idle()
{
	aiScriptedAnim($npc_strauss, "strauss_idle", 1, 0) ;
}

// Harper
void animateHarper_harper_idle()
{
	aiScriptedAnim($npc_harper, "harper_idle", 1, 0);
	
	entity head = $npc_harper.getHead();
	
	if ( isValidEntity( head ))
	{
		head.playAnim( ANIMCHANNEL_ALL, "harperhead_outro" );
	}

}

// Phone
void animatePhone_idle()
{
	$phone.playAnim(ANIMCHANNEL_ALL, "idle");
}

// Dropship
void animateDropship_outro_dropship()
{
	$outro_dropship.playAnim(ANIMCHANNEL_ALL, "outro_dropship");
	sys.wait(25);
	sys.trigger($light_1846); //turn off red spinner
}

// MCC_Ship
void animateMCC_ship_outro_mcc()
{
	$outro_mcc.playAnim(ANIMCHANNEL_ALL, "outro_mcc");

}

// VO
void playVO_3_2_10_10_4()
{
	aiSpeak($npc_morris, "lipsync_vo_3_2_10_10_4");
}

void playVO_3_2_10_10_5()
{
	aiSpeak($npc_strauss, "lipsync_vo_3_2_10_10_5");
}

void playVO_3_2_10_10_6()
{
	aiSpeak($npc_sledge, "lipsync_vo_3_2_10_10_6");
}

void playVO_3_2_10_10_7()
{
	aiSpeak($npc_rhodes, "lipsync_vo_3_2_10_10_7");

	$speaker_music_4.remove();

}

void playVO_3_2_10_10_8()
{
	aiSpeak($npc_cortez, "lipsync_vo_3_2_10_10_8");
}

void playVO_3_2_10_10_11()
{
	aiSpeak($npc_rhodes, "lipsync_vo_3_2_10_10_11");
}

void playVO_3_2_10_10_12()
{
	aiSpeak($npc_cortez, "lipsync_vo_3_2_10_10_12");
}

void camera2Start()
{
	//thread animateKane_kain_idle();
	//thread animateRhodes_rhodes_idle();
	//thread animateSledge_sledge_idle();
	//thread animateCortez_cortez_idle();
	//thread animateStrauss_strauss_idle();
	//thread animateMorris_morris_idle();
	//thread animateHarper_harper_idle();
	thread animateDropship_outro_dropship();
	
	//remove the end boss helper entities
	$monster_makron_legs_1.remove();
	$boss_brain.remove();
	$death.remove();
}

void endingMusic()
{
	//sys.trigger( $tgt_fademusic_in );
	sys.trigger( $speaker_music_5 );
	sys.trigger( $speaker_evil_laugh );
}

// frame 1600
void _showEndLogo()	
{
	sys.sendNamedEvent( GUI_CINEMATICHUD, "endLogo" );
	float n = 0;
	while(1)	{
		sys.println( n + " seconds");
		sys.wait(1);
		n++;
	}
}

void showEndlogo()
{
	thread _showEndLogo();
}

void allLaugh()
{
	float f = 0;
}

void streamerScrolling() {
	
	// fancy stuff to make sure that the shader effects don't get out of sync with the effects emitters

	float streamerPosition = 0;
	float oldTime = sys.getTime();
	float nowTime = sys.getTime();
	float startTime = sys.getTime();
	float deltaTime;
	float streamerState = 0;
	float streamerSpeed = -0.125;
	
	while(1){
		
		nowTime = sys.getTime();
		deltaTime = nowTime - oldTime;
		oldTime = nowTime;
	
		streamerPosition += streamerSpeed * deltaTime;
		$coreStreamers.setShaderParm(4, streamerPosition);

		if ((nowTime - startTime) >= 8.0) {
			//sys.print("reset");
			startTime = nowTime;
			streamerState = 0;
		} else if ((nowTime - startTime) >= 1.7 && streamerState == 2) {
			//sys.print("third one");
			sys.trigger($thirdHex);
			streamerState = 3;
		} else if ((nowTime - startTime) >= 1.4 && streamerState == 1) {
			//sys.print("second one");
			sys.trigger($secondHex);
			streamerState = 2;
		} else if ((nowTime - startTime) >= 0.35 && streamerState == 0) {
			//sys.print("first one");
			sys.trigger($firstHex);
			streamerState = 1;
		}
		
		sys.waitFrame();
	
	}

}

void manageSpawnedMonsters( entity entMonster )	{

	$tgt_monsterManager.appendTarget( entMonster );
	$tgt_monsterManager.removeNullTargets();
}


//-----------------------------------------------------------------------
void main()
{
	//take care of the teleportation sequence
	thread introTeleport();

	//core_probe
	thread assembleProbeElevator();

	OpenBigDoors();			// door start closed, open them fast
	thread CloseBigDoors();	// close doors, yup.
	
	//set up the probe sequence
	$env_verification_arm_1.playAnim(ANIMCHANNEL_ALL, "probe_end" );
}
//-----------------------------------------------------------------------

//end map_core namespace
}

//-----------------------------------------------------------------------//-----------------------------------------------------------------------

 // ***************** MAP CORE2 *******************

//-----------------------------------------------------------------------//-----------------------------------------------------------------------


namespace map_core2	{


// Stuff to play and do when the map starts
void introEffects()	{

	//wait a bit
	sys.wait(1);

	//chatta
	sys.trigger( $chatter_strauss_1 );
}


// Main-----------------
void main()	{

	//thread the intro stuff, VO from strauss, any other effects we might want.
	thread introEffects();
}

}