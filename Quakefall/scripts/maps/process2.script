//now include the functions
//#include "scripts/maps/process2/horseshoe.script" UNUSED
//#include "scripts/maps/process2/comm_core.script" UNUSED

namespace map_process2
{

//------------------------------------------------------------------------------
// Globals

	//turns on when the intro elevator has reached it's destination.
	float g_introElevatorDone = 0;

	//counter for the baddies in the first puzzle room
//	float g_firstPuzzleBaddiesKilled = 0;

	//first puzzle complete
	float g_firstPuzzleComplete = 0;
	
	//brain room complete
	float g_activateBeamComplete = 0;

	//8 node puzzle initialized
	float g_puzzleReady = 0;

	//keeps track of which node in the 20-node puzzle is currently being controlled
	//entity g_currentNode; UNUSED

//------------------------------------------------------------------------------
// Prototypes

//LASER PUZZLE FUNCTIONS

//recursively adjusts all nodes to reflect a change in the beam
void updateNode(entity laserNode, entity source); 

//rotates a lasernode elbow
void rotateNode(entity laserNode, float rotateClockwise);

//functions to determine whether something is in a general direction compared to the node
boolean isItWest(entity it, entity node);
boolean isItEast(entity it, entity node);
boolean isItNorth(entity it, entity node);
boolean isItSouth(entity it, entity node);
boolean isItUp(entity it, entity node);
boolean isItDown(entity it, entity node);

//functions to determine whether something is lined up with a node's beam
boolean isItAlignedX(entity it, entity node, float accuracy);
boolean isItAlignedY(entity it, entity node, float accuracy);
boolean isItAlignedZ(entity it, entity node, float accuracy);

//determines whether an effect is turned on or not
boolean effectTurnedOn(entity effect);

//turn effects off and on
void effectOn(entity effect);
void effectOff(entity effect);
void toggleEffectOnOff(entity effect);

//OTHER FUNCTIONS

//functions for the 8-node puzzle room
void rotateNodeA1();
void rotateNodeA2();
void rotateNodeA3();
void rotateNodeB1();
void rotateNodeB3();
void rotateNodeC1();
void rotateNodeC2();
void rotateNodeC3();
void togglePuzzleDoorLockUnlock();

//called when a transfer in the first puzzle room is slain
//ai_trigger replaced this function -corey
//void firstPuzzleBaddieKill();

//prepares sledge for the stuff he says in the first puzzle.
//void firstPuzzleSledge(); appears to be unused -corey

//rotates a lasernode elbow
//void rotateLasernodeElbow(entity laserNode, float rotateClockwise); UNUSED

//dragon squad radio message
//void dragonRadio();

//if the beam onthe roof hasn't been activated, call this when we try to go to the elevator
void elevatorBusta();

//the end of the brain room-- a hack for now.
// void brainEnd();

//set up the 8-node laser puzzle
void initLaserPuzzle();

/* 
Laser system assumptions:

1) Each node consists of a right angle joint with a single input and a single output.  (Joints with more than 
	one input or output may be added if time permits.)
2) Nodes cannot be any angle besides 90 degrees, though 180 degree joints might be added if time permits.
3) Each node can only rotate around one axis, and that axis must be x, y, or z (no weird vectors).
4) There will be no obstructions between the beam source and its destination.  This means that the beam has 
	to be in a place where the player and movable objects can't intersect it.  I'm not happy with this 
	requirement, and I'll do something about it if I find a way to handle it gracefully.
5) There is only one laser interacting with nodes.  (Will change this if time permits.)

To use this system:

Each node must have exactly two inputs.  These are places where the beam can enter or exit the node.  Each 
input should have a func_fx bound to it, and key values called input1 and input2, which hold the names of the
func_fx bound to the inputs.  When binding the func_fx to the joint, be sure to use bindPosition, because a 
normal bind will cause the effects to play improperly if the node has been rotated.

If the node can be positioned such that an incoming beam will not hit an input, it should have a func_fx bound 
to each point where the laser can hit.  The node should have key values called impact1, impact2, impact3 and 
impact4, which hold the names of each func_fx.  These values do not need to be filled in for positions that 
can't possibly be hit by a laser.

Each node also has to contain key values for any objects that the beam can hit after being redirected by the
joint.  If the redirected beam can hit one or more joints, those joints should be named in appropriately
named keys.  To add a node key, call it Node + first letter of the direction + a number (1 to 3).  So if the
output can potentially hit two nodes in the South direction, those nodes must be listed in keys called
NodeS1 and NodeS2.  Other valid keys are NodeE3 (third east node), NodeN1 (first north node), NodeW1 (first 
west node), NodeU3 (third up node), and NodeD2 (second down node).  Adding more than three nodes per direction
is doable, but will require a small change to the script.  If the output beam can hit something other than a
node, a func_fx needs to be created at that location, and the name of the func_fx needs to be stored in an
appropriately named key.  To add one, call it Wall + first letter of the direction + a number (1 to 3).  So
WallW1 is the first non-node obstacle (usually a wall) that the beam can hit in the west direction.  Finally,
if the output beam from the node can be redirected to open a door (or do anything that solves the puzzle, that 
also needs to be listed in a key.  To add a door key, call it Door1, Door2, or Door3.  Then place a trigger at
the place where the beam will stop.  Once the beam hits it, it will be triggered so that "puzzle complete" 
code can be run.  Also, the beam will stop wherever that trigger is, so it's best to place it directly on the
door.  The only other piece the system needs is a beam target.  Each input fx can also be an output, so it
needs to be set up to play th beam effect.  Make it target a target_null, and record the name of the 
target_null in the node with a key called beamTarget.  It does not matter where this target is placed.  Any 
time a node is moved, the code will automatically move the beam target to where it needs to be.

*/

boolean isItWest(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaX) > abs(deltaY) && abs(deltaX) > abs(deltaZ)) // if the greatest displacement is in the x direction
	{
		if (deltaX < 0) // and if it is westward displacement
			return true;
	}
	return false;
}

boolean isItEast(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaX) > abs(deltaY) && abs(deltaX) > abs(deltaZ)) // if the greatest displacement is in the x direction
	{
		if (deltaX > 0) // and if it is eastward displacement
			return true;
	}
	return false;
}

boolean isItNorth(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaY) > abs(deltaX) && abs(deltaY) > abs(deltaZ)) // if the greatest displacement is in the y direction
	{
		if (deltaY > 0) // and if it is northward displacement
			return true;
	}
	return false;
}

boolean isItSouth(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaY) > abs(deltaX) && abs(deltaY) > abs(deltaZ)) // if the greatest displacement is in the y direction
	{
		if (deltaY < 0) // and if it is southward displacement
			return true;
	}
	return false;
}

boolean isItUp(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaZ) > abs(deltaY) && abs(deltaZ) > abs(deltaX)) // if the greatest displacement is in the z direction
	{
		if (deltaZ > 0) // and if it is upward displacement
			return true;
	}
	return false;
}

boolean isItDown(entity it, entity node)
{
	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();
	float deltaX = itsPos_x - nodePos_x;
	float deltaY = itsPos_y - nodePos_y;
	float deltaZ = itsPos_z - nodePos_z;

	if (abs(deltaZ) > abs(deltaY) && abs(deltaZ) > abs(deltaX)) // if the greatest displacement is in the z direction
	{
		if (deltaZ < 0) // and if it is downward displacement
			return true;
	}
	return false;
}



boolean isItAlignedX(entity it, entity node, float accuracy)
{
//	sys.println("isItAlignedX called");

	if (it == $nullEntity)
		return false;

	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();

	if (abs(itsPos_y - nodePos_y) > accuracy)
		return false;
	if (abs(itsPos_z - nodePos_z) > accuracy)
		return false;
	else
		return true;
}

boolean isItAlignedY(entity it, entity node, float accuracy)
{
//	sys.println("isItAlignedY called");

	if (it == $nullEntity)
		return false;

	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();

	if (abs(itsPos_x - nodePos_x) > accuracy)
		return false;
	if (abs(itsPos_z - nodePos_z) > accuracy)
		return false;
	else
		return true;
}

boolean isItAlignedZ(entity it, entity node, float accuracy)
{
//	sys.println("isItAlignedZ called");

	if (it == $nullEntity)
		return false;

	vector itsPos = it.getWorldOrigin();
	vector nodePos = node.getWorldOrigin();

	if (abs(itsPos_y - nodePos_y) > accuracy)
		return false;
	if (abs(itsPos_x - nodePos_x) > accuracy)
		return false;
	else
		return true;
}


boolean effectTurnedOn(entity effect)
{
	if (effect.getFloatKey("on") > 0)
	{
		return true;
	}
    return false;

}


void effectOn(entity effect)
{
	effect.start();
	effect.setKey("on", 1);
}

void effectOff(entity effect)
{
	effect.stop();
	effect.setKey("on", 0);
}



void toggleEffectOnOff(entity effect)
{
	if (effectTurnedOn(effect))
		effectOff(effect);
	else
		effectOn(effect);
}


/**************************************************************************************************
void updateNode
Parameters:  
	entity laserNode - the node that is being updated
	entity source - an object (usually another node) in the direction where the beam is coming from
This function determines what should happen when a beam pointing to the node is turned on or off.  
It handles playing an impact effect if the beam does not line up with the node's orientation, or 
outputting a new beam if it is lined up properly.  If it does output a beam, it also recursively 
updates any node the beam hits.
**************************************************************************************************/
void updateNode(entity laserNode, entity source)
{
	sys.waitFrame(); // make sure the previous node has had a chance to finish updating

	entity input = $nullEntity; // the func_fx of the input (null if the beam is not lined up properly)
	entity output = $nullEntity; // the func_fx of the output (null if the beam is not lined up properly)
	entity impact = $nullEntity; // the func_fx of a spot on the node being hit by an incoming beam (null if lined up properly)
	entity target = $nullEntity; // the node or func_fx that the output beam will hit (null if not lined up properly)
	
	entity input1 = sys.getEntity(laserNode.getKey("input1"));
	entity input2 = sys.getEntity(laserNode.getKey("input2"));
	entity tempEntity = $nullEntity;

	if (input1 == $nullEntity)
	{
		sys.println("ERROR: laserNode " + laserNode.getName() + " has no input1");
		return;
	}
	if (input2 == $nullEntity)
	{
		sys.println("ERROR: laserNode " + laserNode.getName() + " has no input2");
		return;
	}

	// First, determine where the incoming beam is pointing and get the impact point
	if (isItWest(source, laserNode)) // if the beam goes from west to east (the beam will hit the west side of the joint)
	{
		// see if an input is facing west
		if (isItWest(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		else if (isItWest(input2, laserNode))
		{
			input = input2;
			output = input1;
		}
			
		// see if there is an impact point for the incoming beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItWest(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItWest(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItWest(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItWest(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}
	else if (isItEast(source, laserNode)) // if the beam goes from east to west (the beam will hit the east side)
	{
		// see if an input is facing east
		if (isItEast(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		
		else if (isItEast(input2, laserNode))
		{
			input = input2;
			output = input1;
		}
			
		// see if there is an impact point for the beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItEast(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItEast(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItEast(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItEast(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}

	else if (isItNorth(source, laserNode)) // if the beam goes from north to south (the beam will hit the north side)
	{
		// see if an input is facing north
		if (isItNorth(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		else if (isItNorth(input2, laserNode))
		{
			input = input2;
			output = input1;
		}

		// see if there is an impact point for the beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItNorth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItNorth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItNorth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItNorth(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}
	else if (isItSouth(source, laserNode)) // if the beam goes from south to north (the beam will hit the south side)
	{
		// see if an input is facing south
		if (isItSouth(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		else if (isItSouth(input2, laserNode))
		{
			input = input2;
			output = input1;
		}
	
		// see if there is an impact point for the beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItSouth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItSouth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItSouth(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItSouth(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}
	else if (isItDown(source, laserNode)) // if the beam goes from down to up (the beam will hit the bottom)
	{
		// see if an input is facing down
		if (isItDown(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		else if (isItDown(input2, laserNode))
		{
			input = input2;
			output = input1;
		}
			
		// see if there is an impact point for the beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItDown(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItDown(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItDown(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItDown(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}
	else if (isItUp(source, laserNode)) // if the beam goes from up to down (the beam will hit the top)
	{
		// see if an input is facing up
		if (isItUp(input1, laserNode))
		{
			input = input1;
			output = input2;
		}
		else if (isItUp(input2, laserNode))
		{
			input = input2;
			output = input1;
		}
	
		// see if there is an impact point for the beam to hit
		if (input == $nullEntity) // if there is no input in line with the beam
		{
			// try to find another point for the beam to hit
			tempEntity = sys.getEntity(laserNode.getKey("impact1"));
			if (tempEntity != $nullEntity)
			{
				if (isItUp(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact2"));
			if (tempEntity != $nullEntity)
			{
				if (isItUp(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact3"));
			if (tempEntity != $nullEntity)
			{
				if (isItUp(tempEntity, laserNode))
					impact = tempEntity;
			}
			tempEntity = sys.getEntity(laserNode.getKey("impact4"));
			if (tempEntity != $nullEntity)
			{
				if (isItUp(tempEntity, laserNode))
					impact = tempEntity;
			}
		}
	}
	else
	{
		// something has gone wrong
		sys.println("ERROR: updateNode - source node and current node are in the same location");
	}

	// We should now have either an input and output, or an impact point.  
	if (input == $nullEntity || output == $nullEntity)
	{
		if (impact == $nullEntity)
		{
			sys.println("ERROR: updateNode - could not find input/output or impact point");
			sys.println(laserNode.getKey("name"));
		}
	}
	
	// move the previous node's fx target to the current node's input func_fx
	tempEntity = $nullEntity;
	tempEntity = sys.getEntity(source.getKey("beamTarget"));
	if (tempEntity != $nullEntity)
	{
		// teleport the last node's beam target to the input of this node
		tempEntity.setWorldOrigin(laserNode.getWorldOrigin());
	}

	// if it's just an impact point, turn it off/on and return
	if (impact != $nullEntity)
	{
		toggleEffectOnOff(impact);
		return;
	}

	// it's an input, so play the appropriate sound	

	if (effectTurnedOn(input))
	{
		// the effect is on, about to be turned off
		laserNode.startSoundShader("process_laser_disconnect", SND_CHANNEL_ANY);
	}
	else 
	{
		// the effect is off, about to be turned on
		laserNode.startSoundShader("process_laser_connect", SND_CHANNEL_ANY);
	}

	// try to find out what the output will hit

	if (isItWest(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeW1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeW1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeW2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeW2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeW3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeW3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated

			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);

			return;
		}			

		// then look for walls
		if (isItAlignedX(sys.getEntity(laserNode.getKey("wallW1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallW1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("wallW2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallW2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("wallW3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallW3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedX(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	else if (isItEast(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeE1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeE1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeE2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeE2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("nodeE3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeE3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated

			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);
			return;
		}	

		// then look for walls
		if (isItAlignedX(sys.getEntity(laserNode.getKey("wallE1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallE1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("wallE2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallE2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("wallE3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallE3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedX(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedX(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	else if (isItNorth(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeN1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeN1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeN2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeN2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeN3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeN3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated

			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);
			return;
		}	

		// then look for walls
		if (isItAlignedY(sys.getEntity(laserNode.getKey("wallN1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallN1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("wallN2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallN2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("wallN3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallN3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedY(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	else if (isItSouth(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeS1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeS1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeS2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeS2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("nodeS3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeS3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated
			
			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);
			return;
		}	

		// then look for walls
		if (isItAlignedY(sys.getEntity(laserNode.getKey("wallS1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallS1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("wallS2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallS2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("wallS3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallS3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedY(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedY(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	else if (isItUp(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeU1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeU1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeU2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeU2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeU3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeU3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated

			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);
			return;
		}	

		// then look for walls
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallU1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallU1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallU2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallU2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallU3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallU3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	else if (isItDown(output, laserNode))
	{
		// look for nodes first
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeD1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeD1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeD2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeD2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("nodeD3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("nodeD3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at a node, so that node also needs to be updated
			
			// update the next node
			updateNode(target, laserNode); 

			// start the effect last to be sure all targets are updated
            toggleEffectOnOff(output);
			return;
		}	

		// then look for walls
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallD1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallD1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallD2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallD2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("wallD3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("wallD3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing at an obstacle

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);
			// turn on the wall impact effect
			toggleEffectOnOff(target);
			return;
		}

		// then look for doors
		if (isItAlignedZ(sys.getEntity(laserNode.getKey("door1")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door1"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("door2")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door2"));
		else if (isItAlignedZ(sys.getEntity(laserNode.getKey("door3")), laserNode, 8))
			target = sys.getEntity(laserNode.getKey("door3"));
		if (target != $nullEntity)
		{
			// the output beam is pointing to a door, so trigger the door relay

			// point the beam in that direction
			tempEntity = sys.getEntity(laserNode.getKey("beamTarget"));
			tempEntity.setWorldOrigin(target.getWorldOrigin());

			// turn on the beam effect
			toggleEffectOnOff(output);

			// run the "puzzle solved" code
			sys.trigger(target);
			//sys.println("puzzle solved/unsolved: " + target.getName() + " triggered");

			return;
		}
	}

	if (target == $nullEntity)
	{
		sys.println("ERROR: updateNode " + laserNode.getName() + " - can't find output beam's target");
		return;
	}
}


void rotateNode(entity laserNode, float rotateClockwise)
{
	float axis = laserNode.getFloatKey("rotAxis");
	float angle = laserNode.getFloatKey("rotValue"); // rotValue is an angle: 0, 90, 180 or 270
	entity fx = $nullEntity; // an entity to hold the current func_fx

	// some variables to record whether a beam is currently pointing here from that direction
	boolean west = false;
	boolean east = false;
	boolean north = false;
	boolean south = false;
	boolean up = false;
	boolean down = false;

	// For some situations, it won't work to simply update the node.  For example, if a beam is redirected through node N,
	// and later in the beam's path, it impacts the side of node N, and node N is then rotated, there will essentially be
	// two source lasers striking node N from different directions.  To get around this, keep track of which effects are 
	// currently turned on and record their directions.  Then turn off the effects for the rotation, then choose which 
	// effects to turn on again based on the recorded directions.  If one of the directions is that of an input node, the
	// node can be updated using the func_fx of the input as the source beam.

	// record the directions where beams are coming from

	fx = sys.getEntity(laserNode.getKey("input1"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			// The inputs are a little different than the impacts, because if it is turned on, that means the beam is
			// coming out of that direction, and coming in from the direction of the other end of the node.  So record 
			// the direction for the other input instead.

			fx = sys.getEntity(laserNode.getKey("input2")); // temporarily switch to the other input

			if (isItWest(fx, laserNode))
				west = true;
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;

			// To turn off the beam, update the current node as if the incoming beam had stopped.
			// That way the beam's target will also get updated.
            updateNode(laserNode, fx);

			fx = sys.getEntity(laserNode.getKey("input1")); // switch it back

			
		}
	}

	fx = sys.getEntity(laserNode.getKey("input2"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			// The inputs are a little different than the impacts, because if it is turned on, that means the beam is
			// coming out of that direction, and coming in from the direction of the other end of the node.  So record 
			// the direction for the other input instead.

			fx = sys.getEntity(laserNode.getKey("input1")); // temporarily switch to the other input

			if (isItWest(fx, laserNode))
				west = true;
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;

			// To turn off the beam, update the current node as if the incoming beam had stopped.
			// That way the beam's target will also get updated.
            updateNode(laserNode, fx);

            fx = sys.getEntity(laserNode.getKey("input2")); // switch it back
		}
	}


    fx = sys.getEntity(laserNode.getKey("impact1"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			if (isItWest(fx, laserNode))
				west = true; 
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;

			effectOff(fx);
		}
	}

    fx = sys.getEntity(laserNode.getKey("impact2"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			if (isItWest(fx, laserNode))
				west = true; 
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;
			
			effectOff(fx);
		}
	}
    fx = sys.getEntity(laserNode.getKey("impact3"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			if (isItWest(fx, laserNode))
				west = true;
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;

			effectOff(fx);
		}
	}
    fx = sys.getEntity(laserNode.getKey("impact4"));
	if (fx != $nullEntity)
	{
		if (effectTurnedOn(fx))
		{
			if (isItWest(fx, laserNode))
				west = true;
			else if (isItEast(fx, laserNode))
				east = true;
			else if (isItNorth(fx, laserNode))
				north = true;
			else if (isItSouth(fx, laserNode))
				south = true;
			else if (isItUp(fx, laserNode))
				up = true;
			else if (isItDown(fx, laserNode))
				down = true;

			effectOff(fx);
		}
	}

	// rotate the node
	laserNode.time(1);

	if (rotateClockwise > 0)
	{
		angle += 90;
		if (angle >= 360)
			angle -= 360;
		laserNode.rotateUpTo(axis, angle);
	}
	else 
	{
		angle -= 90;
		if (angle < 0)
			angle += 360;
		laserNode.rotateDownTo(axis, angle);
	}

	laserNode.startSoundShader("process_node_movement", SND_CHANNEL_ANY);
	sys.waitFor(laserNode);

	laserNode.setKey("rotValue", angle);

	// to update the node, try impact points first

	fx = sys.getEntity(laserNode.getKey("impact1"));
	if (fx != $nullEntity)
	{
		if (west && isItWest(fx, laserNode))
			effectOn(fx);
		else if (east && isItEast(fx, laserNode))
			effectOn(fx);
		else if (north && isItNorth(fx, laserNode))
			effectOn(fx);
		else if (south && isItSouth(fx, laserNode))
			effectOn(fx);
		else if (up && isItUp(fx, laserNode))
			effectOn(fx);
		else if (down && isItDown(fx, laserNode))
			effectOn(fx);
	}

	fx = sys.getEntity(laserNode.getKey("impact2"));
	if (fx != $nullEntity)
	{
		if (west && isItWest(fx, laserNode))
			effectOn(fx);
		else if (east && isItEast(fx, laserNode))
			effectOn(fx);
		else if (north && isItNorth(fx, laserNode))
			effectOn(fx);
		else if (south && isItSouth(fx, laserNode))
			effectOn(fx);
		else if (up && isItUp(fx, laserNode))
			effectOn(fx);
		else if (down && isItDown(fx, laserNode))
			effectOn(fx);
	}

	fx = sys.getEntity(laserNode.getKey("impact3"));
	if (fx != $nullEntity)
	{
		if (west && isItWest(fx, laserNode))
			effectOn(fx);
		else if (east && isItEast(fx, laserNode))
			effectOn(fx);
		else if (north && isItNorth(fx, laserNode))
			effectOn(fx);
		else if (south && isItSouth(fx, laserNode))
			effectOn(fx);
		else if (up && isItUp(fx, laserNode))
			effectOn(fx);
		else if (down && isItDown(fx, laserNode))
			effectOn(fx);
	}

	fx = sys.getEntity(laserNode.getKey("impact4"));
	if (fx != $nullEntity)
	{
        if (west && isItWest(fx, laserNode))
			effectOn(fx);
		else if (east && isItEast(fx, laserNode))
			effectOn(fx);
		else if (north && isItNorth(fx, laserNode))
			effectOn(fx);
		else if (south && isItSouth(fx, laserNode))
			effectOn(fx);
		else if (up && isItUp(fx, laserNode))
			effectOn(fx);
		else if (down && isItDown(fx, laserNode))
			effectOn(fx);
	}

	// now try the input points, and update the node normally if found

	fx = sys.getEntity(laserNode.getKey("input1"));
	if (fx != $nullEntity)
	{
		if (west && isItWest(fx, laserNode))
			updateNode(laserNode, fx); // on
		else if (east && isItEast(fx, laserNode))
			updateNode(laserNode, fx);
		else if (north && isItNorth(fx, laserNode))
			updateNode(laserNode, fx);
		else if (south && isItSouth(fx, laserNode))
			updateNode(laserNode, fx);
		else if (up && isItUp(fx, laserNode))
			updateNode(laserNode, fx);
		else if (down && isItDown(fx, laserNode))
			updateNode(laserNode, fx);
	}

	fx = sys.getEntity(laserNode.getKey("input2"));
	if (fx != $nullEntity)
	{
		if (west && isItWest(fx, laserNode))
			updateNode(laserNode, fx);
		else if (east && isItEast(fx, laserNode))
			updateNode(laserNode, fx);
		else if (north && isItNorth(fx, laserNode))
			updateNode(laserNode, fx);
		else if (south && isItSouth(fx, laserNode))
			updateNode(laserNode, fx);
		else if (up && isItUp(fx, laserNode))
			updateNode(laserNode, fx);
		else if (down && isItDown(fx, laserNode))
			updateNode(laserNode, fx);
	}

}


void rotateNodeA1()
{
	rotateNode($mvr_lasernodeA1_pivot, 0);
}

void rotateNodeA2()
{
	rotateNode($mvr_lasernodeA2_pivot, 0);
}

void rotateNodeA3()
{
	rotateNode($mvr_lasernodeA3_pivot, 0);
}

void rotateNodeB1()
{
	rotateNode($mvr_lasernodeB1_pivot, 0);
}

void rotateNodeB3()
{
	rotateNode($mvr_lasernodeB3_pivot, 0);
}

void rotateNodeC1()
{
	rotateNode($mvr_lasernodeC1_pivot, 0);
}

void rotateNodeC2()
{
	rotateNode($mvr_lasernodeC2_pivot, 0);
}

void rotateNodeC3()
{
	rotateNode($mvr_lasernodeC3_pivot, 0);
}


void togglePuzzleDoorLockUnlock()
{
	if ($door_typical_131.getFloatKey("locked") > 0)
	{
		//sys.println("unlock door");
		$door_typical_131.lock(0);
		$door_typical_131.setShaderParm(7,1); // green lights
		$door_frame_8_node_puzzle.setShaderParm(7,1);
		
		//fix for missing effect
		sys.trigger( $fx_puzzleEndDoorFix );
		
		aiSpeak($npc_sledge, "lipsync_vo_3_1_15_30_1");
		
		//success sound
		sys.trigger($speaker_162);
		sys.trigger ($node_puzzle_solve_pa);
		
		//tether sledge to player
		sys.trigger($ai_tether_none_sledge);
	}
	else
	{
		//sys.println("lock door");
		$door_typical_131.lock(1);
		$door_typical_131.setShaderParm(7,0); // red lights
		$door_frame_8_node_puzzle.setShaderParm(7,0);
		
		//fix for missing effect
		sys.trigger( $fx_puzzleEndDoorFix );
		
		//tether sledge to his waiting point near the console
		sys.trigger($ai_tether_radius_9);
	}
}


/*void toggle20topPuzzleSolved()
{
	sys.println("top puzzle has been solved or unsolved");
	if ($tgr_open_20_node_puzzle_door.getFloatKey("puzzleSolved") == 0)
		$tgr_open_20_node_puzzle_door.setKey("puzzleSolved", "1");
	else
		$tgr_open_20_node_puzzle_door.setKey("puzzleSolved", "0");

	if ($tgr_open_20_node_puzzle_door.getFloatKey("puzzleSolved") > 0 && $tgr_open_20_node_puzzle_door_1.getFloatKey("puzzleSolved") > 0)
	{
		sys.println("unlock door");
		$door_typical_133.lock(0);
		$door_typical_133.setShaderParm(7,1); // green lights
		$door_frame_20_node_puzzle.setShaderParm(7,1);
	}
	else
	{
		sys.println("lock door");
		$door_typical_133.lock(1);
		$door_typical_133.setShaderParm(7,0); // red lights
		$door_frame_20_node_puzzle.setShaderParm(7,0);
	}
} UNUSED */

/*void toggle20bottomPuzzleSolved()
{
	sys.println("bottom puzzle has been solved or unsolved");
	toggleEffectOnOff($fx_split_beam_1);
	toggleEffectOnOff($fx_split_beam_2);

	if ($tgr_open_20_node_puzzle_door_1.getFloatKey("puzzleSolved") == 0)
		$tgr_open_20_node_puzzle_door_1.setKey("puzzleSolved", "1");
	else
		$tgr_open_20_node_puzzle_door_1.setKey("puzzleSolved", "0");

		if ($tgr_open_20_node_puzzle_door.getFloatKey("puzzleSolved") > 0 && $tgr_open_20_node_puzzle_door_1.getFloatKey("puzzleSolved") > 0)
	{
		sys.println("unlock door");
		$door_typical_133.lock(0);
		$door_typical_133.setShaderParm(7,1); // green lights
		$door_frame_20_node_puzzle.setShaderParm(7,1);
	}
	else
	{
		sys.println("lock door");
		$door_typical_133.lock(1);
		$door_typical_133.setShaderParm(7,0); // red lights
		$door_frame_20_node_puzzle.setShaderParm(7,0);
	}
} UNUSED */


/*void bigNodePuzzleLeftButtonPushed()
{
	// the player has pushed the button to rotate the current node to the left

	// return if the platform is already on the highest level
    vector currentLocation = $nodePlatTall.getOrigin();
	vector levelLocation = $tgt_nodePlat_topLevel.getOrigin(); 
	if (levelLocation_z == currentLocation_z)
		return;

	rotateNode(g_currentNode, 0);
} UNUSED */

/*void bigNodePuzzleRightButtonPushed()
{
	// the player has pushed the button to rotate the current node to the right

	// return if the platform is already on the highest level
    vector currentLocation = $nodePlatTall.getOrigin();
	vector levelLocation = $tgt_nodePlat_topLevel.getOrigin(); 
	if (levelLocation_z == currentLocation_z)
		return;

	rotateNode(g_currentNode, 1);
} UNUSED */



/*void bigNodePuzzlePlatformLeft()
{
	// the player has pushed the button to rotate the platform to the left

	float rotTimeModifier = .02;
	entity nextNode = $nullEntity;

	// determine the angle we need to rotate in order to point at the next node
	float angleToRotate = 0;
	float currentAngle = $nodePlatTall.getFloatKey("rotAngle");

	// trig is slow, so I'll just hard code the values instead of calculating them
	// The angle will always be 45, 73.74, or 8.13 

	if (currentAngle > 359 || currentAngle < 1) // approximately 0, moving from A2 to A1
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeS1")); 
	}
	else if (currentAngle > 44 && currentAngle < 46) // approximately 45, moving from A1 to B1
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}
	else if (currentAngle > 52.13 && currentAngle < 54.13) // approximately 53.13, moving from B1 to C1
	{
		angleToRotate = 73.74;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}
	else if (currentAngle > 125.87 && currentAngle < 127.87) // approximately 126.87, moving from C1 to D1
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}
	else if (currentAngle > 134 && currentAngle < 136) // approximately 135, moving from D1 to D2
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeN1"));
	}
	else if (currentAngle > 179 && currentAngle < 181) // approximately 180, moving from D2 to D3
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeN1"));
	}
	else if (currentAngle > 224 && currentAngle < 226) // approximately 225, moving from D3 to C3
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 232.13 && currentAngle < 234.13) // approximately 233.13, moving from C3 to B3
	{
		angleToRotate = 73.74;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 305.87 && currentAngle < 307.87) // approximately 306.87, moving from B3 to A3
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 314 && currentAngle < 316) // approximately 315, moving from A3 to A2
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeS1"));
	}

	// rotate the platform
	$nodePlatTall.time(angleToRotate * rotTimeModifier); // for some reason $nodePlatTall.speed isn't working
	currentAngle = currentAngle + angleToRotate;
	if (currentAngle >= 360)
		currentAngle = currentAngle - 360;
	$nodePlatTall.rotateUpTo(1, currentAngle);
	$nodePlatTall.setKey("rotAngle", currentAngle);

	// update the currently selected node g_currentNode
	g_currentNode = nextNode;
	sys.println("now pointing to " + g_currentNode.getName());
} UNUSED */

/*void bigNodePuzzlePlatformRight()
{
	// the player has pushed the button to rotate the platform to the right
	
	float rotTimeModifier = .02;
	entity nextNode = $nullEntity;

	// determine the angle we need to rotate in order to point at the next node
	float angleToRotate = 0;
	float currentAngle = $nodePlatTall.getFloatKey("rotAngle");

	// trig is slow, so I'll just hard code the values instead of calculating them
	// The angle will always be 45, 73.74, or 8.13 

	if (currentAngle > 359 || currentAngle < 1) // approximately 0, moving from A2 to A3
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeN1"));
	}
	else if (currentAngle > 44 && currentAngle < 46) // approximately 45, moving from A1 to A2
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeN1"));
	}
	else if (currentAngle > 52.13 && currentAngle < 54.13) // approximately 53.13, moving from B1 to A1
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 125.87 && currentAngle < 127.87) // approximately 126.87, moving from C1 to B1
	{
		angleToRotate = 73.74;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 134 && currentAngle < 136) // approximately 135, moving from D1 to C1
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeW1"));
	}
	else if (currentAngle > 179 && currentAngle < 181) // approximately 180, moving from D2 to D1
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeS1"));
	}
	else if (currentAngle > 224 && currentAngle < 226) // approximately 225, moving from D3 to D2
	{
		angleToRotate = 45;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeS1"));
	}
	else if (currentAngle > 232.13 && currentAngle < 234.13) // approximately 233.13, moving from C3 to D3
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}
	else if (currentAngle > 305.87 && currentAngle < 307.87) // approximately 306.87, moving from B3 to C3
	{
		angleToRotate = 73.74;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}
	else if (currentAngle > 314 && currentAngle < 316) // approximately 315, moving from A3 to B3
	{
		angleToRotate = 8.13;
		nextNode = sys.getEntity(g_currentNode.getKey("nodeE1"));
	}

	// rotate the platform
	$nodePlatTall.time(angleToRotate * rotTimeModifier); // for some reason $nodePlatTall.speed isn't working
	currentAngle = currentAngle - angleToRotate;
	if (currentAngle < 0)
		currentAngle = currentAngle + 360;
	$nodePlatTall.rotateDownTo(1, currentAngle);
	$nodePlatTall.setKey("rotAngle", currentAngle);

	// update the currently selected node g_currentNode
	g_currentNode = nextNode;
	sys.println("now pointing to " + g_currentNode.getName());
} UNUSED */

/*void bigNodePuzzlePlatformUp()
{
	// the player has pushed the button to move the platform up
	$nodePlatTall.speed(200);

	vector currentLocation = $nodePlatTall.getOrigin();
	vector levelLocation; 

	// return if the platform is already on the highest level
	levelLocation = $tgt_nodePlat_topLevel.getOrigin();
    if (levelLocation_z == currentLocation_z)				// if you're on the top level
		return;

	levelLocation = $tgt_nodePlat_middleLevel.getOrigin();
	if (levelLocation_z == currentLocation_z)				// if you're on the middle level
	{
		$nodePlatTall.moveTo($tgt_nodePlat_topLevel);
		return;
	}
	else													// you're on the bottom level
		$nodePlatTall.moveTo($tgt_nodePlat_middleLevel);

	sys.waitFor($nodePlatTall);

	// when switching between the bottom and middle levels, update the currently selected node g_currentNode

    g_currentNode = sys.getEntity(g_currentNode.getKey("NodeU1")); // get the node directly above this one
	sys.println("now pointing to " + g_currentNode.getName());
} UNUSED */

/*void bigNodePuzzlePlatformDown()
{
	// the player has pushed the button to move the platform down
	$nodePlatTall.speed(200);

	vector currentLocation = $nodePlatTall.getOrigin();
	vector levelLocation; 

	// return if the platform is already on the lowest level
	levelLocation = $tgt_nodePlat_bottomLevel.getOrigin();
    if (levelLocation_z == currentLocation_z)				// if you're on the bottom level
		return;

	levelLocation = $tgt_nodePlat_topLevel.getOrigin();
	if (levelLocation_z == currentLocation_z)				// if you're on the top level
	{
		$nodePlatTall.moveTo($tgt_nodePlat_middleLevel);
		return;
	}
	else													// you're on the middle level
		$nodePlatTall.moveTo($tgt_nodePlat_bottomLevel);

	sys.waitFor($nodePlatTall);

	// when switching between the bottom and middle levels, update the currently selected node g_currentNode

    g_currentNode = sys.getEntity(g_currentNode.getKey("NodeD1")); // get the node directly below this one
	sys.println("now pointing to " + g_currentNode.getName());
} UNUSED */

void lowerPlatform( )
{
	if ($nodePlatTall.getOrigin() == $tgt_nodePlat_middleLevel.getOrigin())
		return;

	// Lower the platform.
	$nodePlatTall.moveTo($tgt_nodePlat_middleLevel);
	
	//trigger off the aasobstacles for the lower level monsters so they can now pass through the areas
	sys.trigger($nodePlatTall_aas_obstacle_off);

	// Adjust the beam.
	sys.wait(1);
	$tgt_beam_from_door_destination_1.setOrigin($tgr_open_plat_room_door.getOrigin());
	$fx_laser_from_t_node.stop();
	sys.waitFrame();
	$fx_laser_from_t_node.start(); // restart the effect to point at the new location

	
	//Extend the bridge.
	sys.waitFor($nodePlatTall);
	//$mvr_platform_bridge.move(EAST, 400);
	$mvr_platform_bridge.move(0, 248);
	sys.waitFor($mvr_platform_bridge);
	
	//unhide aas_obstacle after move
	sys.trigger($nodePlatTall_aas_obstacle_waitforbridge);
	
	//trigger lights in sequence
	sys.trigger($mvr_platform_light_1);
	sys.trigger($mvr_platform_light_2);
	sys.trigger($mvr_platform_speaker_1);
	sys.wait(.5);
	sys.trigger($mvr_platform_light_3);
	sys.trigger($mvr_platform_light_4);
	sys.trigger($mvr_platform_speaker_2);
	sys.wait(.5);
	sys.trigger($mvr_platform_light_5);
	sys.trigger($mvr_platform_light_6);
	sys.trigger($mvr_platform_speaker_3);	
}

void raisePlatform()
{	
	if ($nodePlatTall.getOrigin() == $tgt_nodePlat_topLevel.getOrigin())
		return;

	//unhide aas_obstacle after move
	sys.trigger($nodePlatTall_aas_obstacle_waitforbridge);
	
	//trigger lights in sequence
	sys.trigger($mvr_platform_light_5);
	sys.trigger($mvr_platform_light_6);
	sys.trigger($mvr_platform_speaker_3);
	sys.wait(.5);
	sys.trigger($mvr_platform_light_3);
	sys.trigger($mvr_platform_light_4);
	sys.trigger($mvr_platform_speaker_2);
	sys.wait(.5);
	sys.trigger($mvr_platform_light_1);
	sys.trigger($mvr_platform_light_2);
	sys.trigger($mvr_platform_speaker_1);

	//$mvr_platform_bridge.move(EAST, 400);
	$mvr_platform_bridge.move(0, -248);

	// Adjust the beam.
	sys.wait(1);
	$tgt_beam_from_door_destination_1.setOrigin($tgt_beam_from_door_destination_2.getOrigin());
	$fx_laser_from_t_node.stop();
	sys.waitFrame();
	$fx_laser_from_t_node.start(); // restart the effect to point at the new location
	// sys.trigger($tgr_open_plat_room_door);

	//trigger off the aasobstacles for the lower level monsters so they can now pass through the areas
	sys.trigger($nodePlatTall_aas_obstacle_off);

	// Lower the platform.
	$nodePlatTall.moveTo($tgt_nodePlat_topLevel);
	sys.waitFor($nodePlatTall);
	$monster_gunner_4.remove();
}

void openPlatRoomDoor()
{
	//sys.println("OpenPlatRoomDoor called");
	sys.trigger($door_typical_133);
	sys.trigger($speaker_6);
//	$door_typical_133.setKey("locked", "0");
	$door_typical_133.setShaderParm(7,1);
	$door_frame_20_node_puzzle.setShaderParm(7,1);
}

void beamSetup()
{
	$beam_rail_north.time(.1);
	$beam_rail_south.time(.1);
	$beam_rail_north.move( DOWN,992 );
	$beam_rail_south.move( DOWN,992 );

	$beam_satellite.time(.1);
	$beam_satellite.move( EAST,96 );
	sys.waitFor($beam_satellite);
	$beam_satellite.rotateOnce( '90 0 0' );
}


// -------------------
// This is the most evil hack ever perpetrated upon modern game design:
//
// The beam doesn't fire far enough to still appear to hit the top of the core tower,
// because the beam is locked in place but the skybox moves with the player.
//
// This loop gets the player's position and moves the target point of the beam effect
// to compensate, so that the end point is always over the apparent top of the core tower.
// mbreit | aug 05
// -------------------
void beamParallax() {
	vector pOrg;
	vector cOrg = '-1 0.0234375 0.56875';	// vector to core tower top, x-normalized
	vector nOrg;
	float a;
	while (1) {
		pOrg = $player1.getWorldOrigin() + '0 0 68';	// eye height (standing)
		a = (pOrg_x + 19700); 	// beam fx stop drawing at ~19700 x, so measure x distance
					// from player. without sky caulk this would be the exact 
					// x coordinate of the wall instead (where the beam clips off)
		nOrg = cOrg * a + pOrg;		// multiply core vector to full distance so we're at the end of the beam
		$null_beamTarget.setWorldOrigin( nOrg );	// point the emitter here
	//	sys.println("Origin set to" + nOrg_x + " " + nOrg_y + " " + nOrg_z + ".");
		sys.waitFrame();	// rinse, repeat
	}
}

void beamCoupler()
{	
	// brief warm-up
	$coupler_axis.time(1.5);
	$coupler_axis.accelTime(1.5);
	
	sys.trigger($coupling_spin_sound);
	$coupler_axis.rotateOnce( '0 0 360' );
	sys.waitFor($coupler_axis);

	// now start effect and just rotate forever (could use a func_rotate?)
	thread beamParallax();
	sys.trigger( $fx_roofCoreConnection );
	sys.trigger($beam_blast);
	
	$coupler_axis.time(.25);
	$coupler_axis.accelTime(0);
	
	while(1)
	{
		$coupler_axis.rotateOnce( '0 0 90' );
		sys.waitFor($coupler_axis);
	}
}

void sledgeEndLevelPosition()
{
	// Gets Sledge to his spot at the end of the level.
	
	$npc_sledge.setLeader($null_entity); // sledge doesn't follow you to Process1 second
	aiScriptedMoveWait($npc_sledge, $tgt_sledge_ends_level_here, 16, 1);
	sys.trigger($ai_tether_none_sledge);
	$npc_sledge.lookAt($player1);
	$npc_sledge.forcePosture(AIPOSTURE_STAND);
	aiScriptedFace($npc_sledge, $player1, 1);

}



void activateBeam()
{
	sys.trigger($enable_exit_gui);
	$exit_clip.show();
	
	if (g_activateBeamComplete > 0)
		return;

	g_activateBeamComplete = 0;
	$func_elevator_29.setKey("gui_parm_disable", "0"); // make the end elevator work again

	// rotate the thing you're standing on
	
	$mvr_dishMachines_pivot.time(3);
	$mvr_dishMachines_pivot.rotateDownTo(1, 180);
	sys.waitFor($mvr_dishMachines_pivot);

	// now activate the beam
	
	sys.trigger($disc_sound);
	$disc_north.rotateOnce( '0 -24 0' );
	$disc_south.rotateOnce( '0 24 0' );
	sys.waitFor($disc_south);
	
	sys.trigger($disc_sm_sound);
	$disc_north_sm.rotateOnce( '0 -45 0' );
	$disc_south_sm.rotateOnce( '0 45 0' );
	sys.waitFor($disc_south_sm);

	$beam_rail_north.show();
	$beam_rail_south.show();
	$beam_satellite.show();
	$beam_coupler.show();
		
	$beam_rail_north.time(3);
	$beam_rail_south.time(3);
	
	$beam_satellite.time(3);
	
	sys.trigger($rail_sound);

	$beam_rail_north.move( UP,992 );
	$beam_rail_south.move( UP,992 );
	sys.waitFor($beam_rail_south);
	
	sys.trigger($coupling_rise_sound);
	$beam_satellite.move( UP,464 );	
	sys.waitFor($beam_satellite);
	sys.wait(1);
	sys.trigger($coupling_aim_sound);
	$beam_satellite.move( DOWN,64 );
	$beam_satellite.rotateOnce( '-119.1 0 0' );	// point at top of core tower
	sys.waitFor($beam_satellite);

	thread beamCoupler();

	// closing events
	thread sledgeEndLevelPosition();
	
	// pa announcment about connection - jersey
	sys.trigger ($beam_on_pa);
	sys.wait(2);

	radioChatterPlayWait($radio_strauss_objective_complete, ""); // sledge should stay put
	
	//complete objective
	sys.trigger($objective_totheroof_complete);
	
	aiSpeakWait($npc_sledge, "lipsync_vo_3_1_15_50_2"); // sledge will comply
	radioChatterPlayWait($radio_strauss_order_kane, ""); // kane should go to process1 second
	
	//objective to get to tram
	sys.trigger($objective_elevatoraction);
	
	aiSpeakWait($npc_sledge, "lipsync_vo_3_1_15_50_4"); // goodbye
	$npc_sledge.setTalkState(TALK_OK); 

	sys.trigger($tgr_end_level_alert); // allow the exit alert to be triggered

	// don't allow Sledge to teleport-follow anymore
	$tgr_sledge_follow_1.remove();
	$tgr_sledge_follow_2.remove();
	$tgr_sledge_follow_3.remove();
	$tgr_sledge_follow_4.remove();
	$tgr_sledge_follow_5.remove();
	$tgr_sledge_follow_6.remove();
	$tgr_sledge_follow_7.remove();
	$tgr_sledge_follow_8.remove();
	$tgr_sledge_follow_9.remove();

}

void sledgeTalkAboutRoof()
{
	aiSpeak($npc_sledge, "lipsync_vo_3_1_15_10_1");
		
}


void dataAnalysis1BottomFirst()
{
	$da1Bottompiece1.time( 4 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );
	$da1Bottompiece1.move( UP,96 );

	$da1Bottompiece2.time( 4 );
	$da1Bottompiece2.rotateOnce( '0 -360 0' );
	$da1Bottompiece2.move( UP,96 );

	sys.wait( 4.5 );

	$da1Bottompiece3d.rotateOnce( '360 0 0' );
	$da1Bottompiece3e.rotateOnce( '360 0 0' );
	$da1Bottompiece4d.rotateOnce( '360 0 0' );
	$da1Bottompiece4e.rotateOnce( '360 0 0' );

	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( WEST,32 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( EAST,32 );

	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( EAST,32 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( WEST,32 );

	sys.wait( 2.5 );

	$da1Bottompiece3a.time( 2 );
	$da1Bottompiece3a.move( NORTH,64 );
	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( NORTH,64 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( NORTH,64 );

	$da1Bottompiece4a.time( 2 );
	$da1Bottompiece4a.move( SOUTH,64 );
	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( SOUTH,64 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( SOUTH,64 );

	sys.wait( 2.5 );

	$da1Bottompiece3a.bind($da1Bottompiece1);
	$da1Bottompiece3b.bind($da1Bottompiece1);
	$da1Bottompiece3c.bind($da1Bottompiece1);
	$da1Bottompiece4a.bind($da1Bottompiece1);
	$da1Bottompiece4b.bind($da1Bottompiece1);
	$da1Bottompiece4c.bind($da1Bottompiece1);

	$da1Bottompiece1.time( 3 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );

	$da1Bottompiece2.time( 3 );
	$da1Bottompiece2.rotateOnce( '0 180 0' );

	sys.wait( 3.5 );

	$da1Bottompiece3a.unbind();
	$da1Bottompiece3b.unbind();
	$da1Bottompiece3c.unbind();
	$da1Bottompiece4a.unbind();
	$da1Bottompiece4b.unbind();
	$da1Bottompiece4c.unbind();

	$da1Bottompiece3f.rotateOnce( '360 0 0' );
	$da1Bottompiece3g.rotateOnce( '360 0 0' );
	$da1Bottompiece4f.rotateOnce( '360 0 0' );
	$da1Bottompiece4g.rotateOnce( '360 0 0' );

	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( WEST,32 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( EAST,32 );

	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( EAST,32 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( WEST,32 );

	sys.wait( 2.5 );

	$da1Bottompiece1.time( 4 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );
	$da1Bottompiece1.move( DOWN,96 );

	$da1Bottompiece2.time( 4 );
	$da1Bottompiece2.rotateOnce( '0 -360 0' );
	$da1Bottompiece2.move( DOWN,96 );

	sys.wait( 4.0 );
}

void dataAnalysis1BottomSecond()
{
	$da1Bottompiece1.time( 4 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );
	$da1Bottompiece1.move( UP,96 );

	$da1Bottompiece2.time( 4 );
	$da1Bottompiece2.rotateOnce( '0 -360 0' );
	$da1Bottompiece2.move( UP,96 );

	sys.wait( 4.5 );

	$da1Bottompiece3f.rotateOnce( '360 0 0' );
	$da1Bottompiece3g.rotateOnce( '360 0 0' );
	$da1Bottompiece4f.rotateOnce( '360 0 0' );
	$da1Bottompiece4g.rotateOnce( '360 0 0' );

	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( EAST,32 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( WEST,32 );

	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( WEST,32 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( EAST,32 );

	sys.wait( 2.5 );

	$da1Bottompiece3a.bind($da1Bottompiece1);
	$da1Bottompiece3b.bind($da1Bottompiece1);
	$da1Bottompiece3c.bind($da1Bottompiece1);
	$da1Bottompiece4a.bind($da1Bottompiece1);
	$da1Bottompiece4b.bind($da1Bottompiece1);
	$da1Bottompiece4c.bind($da1Bottompiece1);

	$da1Bottompiece1.time( 3 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );

	$da1Bottompiece2.time( 3 );
	$da1Bottompiece2.rotateOnce( '0 180 0' );

	sys.wait( 3.5 );

	$da1Bottompiece3a.unbind();
	$da1Bottompiece3b.unbind();
	$da1Bottompiece3c.unbind();
	$da1Bottompiece4a.unbind();
	$da1Bottompiece4b.unbind();
	$da1Bottompiece4c.unbind();

	$da1Bottompiece3a.time( 2 );
	$da1Bottompiece3a.move( SOUTH,64 );
	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( SOUTH,64 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( SOUTH,64 );

	$da1Bottompiece4a.time( 2 );
	$da1Bottompiece4a.move( NORTH,64 );
	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( NORTH,64 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( NORTH,64 );

	sys.wait( 2.5 );

	$da1Bottompiece3d.rotateOnce( '360 0 0' );
	$da1Bottompiece3e.rotateOnce( '360 0 0' );
	$da1Bottompiece4d.rotateOnce( '360 0 0' );
	$da1Bottompiece4e.rotateOnce( '360 0 0' );

	$da1Bottompiece3b.time( 2 );
	$da1Bottompiece3b.move( EAST,32 );
	$da1Bottompiece3c.time( 2 );
	$da1Bottompiece3c.move( WEST,32 );

	$da1Bottompiece4b.time( 2 );
	$da1Bottompiece4b.move( WEST,32 );
	$da1Bottompiece4c.time( 2 );
	$da1Bottompiece4c.move( EAST,32 );

	sys.wait( 2.5 );

	$da1Bottompiece1.time( 4 );
	$da1Bottompiece1.rotateOnce( '0 180 0' );
	$da1Bottompiece1.move( DOWN,96 );

	$da1Bottompiece2.time( 4 );
	$da1Bottompiece2.rotateOnce( '0 -360 0' );
	$da1Bottompiece2.move( DOWN,96 );

	sys.wait( 4.0 );
}

void dataAnalysis1TSD1First()
{
	sys.wait( 4.5 );

	// Moves TSD Machine and Base down
	$da1TSD1a.time( 2 );
	$da1TSD1a.move( DOWN,64 );
	$da1TSD1b.time( 2 );
	$da1TSD1b.move( DOWN,64 );
	$da1TSD1c.time( 2 );
	$da1TSD1c.move( DOWN,64 );

	$da1TSD1base1a.time( 2 );
	$da1TSD1base1a.move( DOWN,64 );
	$da1TSD1base1a.rotateOnce( '0 360 0' );
	$da1TSD1base1b.time( 2 );
	$da1TSD1base1b.move( DOWN,64 );
	$da1TSD1base1c.time( 2 );
	$da1TSD1base1c.move( DOWN,64 );

	sys.wait( 2.5 );

	// Moves TSD Machine to other TSD base
	$da1TSD1a.time( 1.5 );
	$da1TSD1a.move( UP,128 );
	$da1TSD1b.time( 1.5 );
	$da1TSD1b.move( UP,128 );
	$da1TSD1c.time( 1.5 );
	$da1TSD1c.move( UP,128 );

	sys.wait( 2 );

	$da1TSD1a.time( 1.0 );
	$da1TSD1a.move( SOUTH,48 );
	$da1TSD1b.time( 1.0 );
	$da1TSD1b.move( SOUTH,48 );
	$da1TSD1c.time( 1.0 );
	$da1TSD1c.move( SOUTH,48 );

	sys.wait( 1.5 );

	$da1TSD1a.time( 2.0 );
	$da1TSD1a.move( DOWN,128 );
	$da1TSD1b.time( 2.0 );
	$da1TSD1b.move( DOWN,128 );
	$da1TSD1c.time( 2.0 );
	$da1TSD1c.move( DOWN,128 );

	sys.wait( 2.5 );

	// Moves TSD Machine and Base up
	$da1TSD1a.time( 2 );
	$da1TSD1a.move( UP,64 );
	$da1TSD1b.time( 2 );
	$da1TSD1b.move( UP,64 );
	$da1TSD1c.time( 2 );
	$da1TSD1c.move( UP,64 );

	$da1TSD1base2a.time( 2 );
	$da1TSD1base2a.move( UP,64 );
	$da1TSD1base2a.rotateOnce( '0 360 0' );
	$da1TSD1base2b.time( 2 );
	$da1TSD1base2b.move( UP,64 );
	$da1TSD1base2c.time( 2 );
	$da1TSD1base2c.move( UP,64 );
}

void dataAnalysis1TSD1Second()
{
	sys.wait( 4.5 );

	// Moves TSD Machine and Base down
	$da1TSD1a.time( 2 );
	$da1TSD1a.move( DOWN,64 );
	$da1TSD1b.time( 2 );
	$da1TSD1b.move( DOWN,64 );
	$da1TSD1c.time( 2 );
	$da1TSD1c.move( DOWN,64 );

	$da1TSD1base2a.time( 2 );
	$da1TSD1base2a.move( DOWN,64 );
	$da1TSD1base2a.rotateOnce( '0 360 0' );
	$da1TSD1base2b.time( 2 );
	$da1TSD1base2b.move( DOWN,64 );
	$da1TSD1base2c.time( 2 );
	$da1TSD1base2c.move( DOWN,64 );

	sys.wait( 2.5 );


	// Moves TSD Machine to other TSD base
	$da1TSD1a.time( 1.5 );
	$da1TSD1a.move( UP,128 );
	$da1TSD1b.time( 1.5 );
	$da1TSD1b.move( UP,128 );
	$da1TSD1c.time( 1.5 );
	$da1TSD1c.move( UP,128 );

	sys.wait( 2 );

	$da1TSD1a.time( 1.0 );
	$da1TSD1a.move( NORTH,48 );
	$da1TSD1b.time( 1.0 );
	$da1TSD1b.move( NORTH,48 );
	$da1TSD1c.time( 1.0 );
	$da1TSD1c.move( NORTH,48 );

	sys.wait( 1.5 );

	$da1TSD1a.time( 2.0 );
	$da1TSD1a.move( DOWN,128 );
	$da1TSD1b.time( 2.0 );
	$da1TSD1b.move( DOWN,128 );
	$da1TSD1c.time( 2.0 );
	$da1TSD1c.move( DOWN,128 );

	sys.wait( 2.5 );

	// Moves TSD Machine and Base up
	$da1TSD1a.time( 2 );
	$da1TSD1a.move( UP,64 );
	$da1TSD1b.time( 2 );
	$da1TSD1b.move( UP,64 );
	$da1TSD1c.time( 2 );
	$da1TSD1c.move( UP,64 );

	$da1TSD1base1a.time( 2 );
	$da1TSD1base1a.move( UP,64 );
	$da1TSD1base1a.rotateOnce( '0 360 0' );
	$da1TSD1base1b.time( 2 );
	$da1TSD1base1b.move( UP,64 );
	$da1TSD1base1c.time( 2 );
	$da1TSD1base1c.move( UP,64 );
}

void dataAnalysis1TSD2First()
{
	sys.wait( 4.5 );

	// Moves TSD Machine and Base down
	$da1TSD2a.time( 2 );
	$da1TSD2a.move( DOWN,64 );
	$da1TSD2b.time( 2 );
	$da1TSD2b.move( DOWN,64 );
	$da1TSD2c.time( 2 );
	$da1TSD2c.move( DOWN,64 );

	$da1TSD2base1a.time( 2 );
	$da1TSD2base1a.move( DOWN,64 );
	$da1TSD2base1a.rotateOnce( '0 360 0' );
	$da1TSD2base1b.time( 2 );
	$da1TSD2base1b.move( DOWN,64 );
	$da1TSD2base1c.time( 2 );
	$da1TSD2base1c.move( DOWN,64 );

	sys.wait( 2.5 );

	// Moves TSD Machine to other TSD base
	$da1TSD2a.time( 1.5 );
	$da1TSD2a.move( UP,128 );
	$da1TSD2b.time( 1.5 );
	$da1TSD2b.move( UP,128 );
	$da1TSD2c.time( 1.5 );
	$da1TSD2c.move( UP,128 );

	sys.wait( 2 );

	$da1TSD2a.time( 1.0 );
	$da1TSD2a.move( NORTH,48 );
	$da1TSD2b.time( 1.0 );
	$da1TSD2b.move( NORTH,48 );
	$da1TSD2c.time( 1.0 );
	$da1TSD2c.move( NORTH,48 );

	sys.wait( 1.5 );

	$da1TSD2a.time( 2.0 );
	$da1TSD2a.move( DOWN,128 );
	$da1TSD2b.time( 2.0 );
	$da1TSD2b.move( DOWN,128 );
	$da1TSD2c.time( 2.0 );
	$da1TSD2c.move( DOWN,128 );

	sys.wait( 2.5 );

	// Moves TSD Machine and Base up
	$da1TSD2a.time( 2 );
	$da1TSD2a.move( UP,64 );
	$da1TSD2b.time( 2 );
	$da1TSD2b.move( UP,64 );
	$da1TSD2c.time( 2 );
	$da1TSD2c.move( UP,64 );

	$da1TSD2base2a.time( 2 );
	$da1TSD2base2a.move( UP,64 );
	$da1TSD2base2a.rotateOnce( '0 360 0' );
	$da1TSD2base2b.time( 2 );
	$da1TSD2base2b.move( UP,64 );
	$da1TSD2base2c.time( 2 );
	$da1TSD2base2c.move( UP,64 );
}

void dataAnalysis1TSD2Second()
{
	sys.wait( 4.5 );

	// Moves TSD Machine and Base down
	$da1TSD2a.time( 2 );
	$da1TSD2a.move( DOWN,64 );
	$da1TSD2b.time( 2 );
	$da1TSD2b.move( DOWN,64 );
	$da1TSD2c.time( 2 );
	$da1TSD2c.move( DOWN,64 );

	$da1TSD2base2a.time( 2 );
	$da1TSD2base2a.move( DOWN,64 );
	$da1TSD2base2a.rotateOnce( '0 360 0' );
	$da1TSD2base2b.time( 2 );
	$da1TSD2base2b.move( DOWN,64 );
	$da1TSD2base2c.time( 2 );
	$da1TSD2base2c.move( DOWN,64 );

	sys.wait( 2.5 );


	// Moves TSD Machine to other TSD base
	$da1TSD2a.time( 1.5 );
	$da1TSD2a.move( UP,128 );
	$da1TSD2b.time( 1.5 );
	$da1TSD2b.move( UP,128 );
	$da1TSD2c.time( 1.5 );
	$da1TSD2c.move( UP,128 );

	sys.wait( 2 );

	$da1TSD2a.time( 1.0 );
	$da1TSD2a.move( SOUTH,48 );
	$da1TSD2b.time( 1.0 );
	$da1TSD2b.move( SOUTH,48 );
	$da1TSD2c.time( 1.0 );
	$da1TSD2c.move( SOUTH,48 );

	sys.wait( 1.5 );

	$da1TSD2a.time( 2.0 );
	$da1TSD2a.move( DOWN,128 );
	$da1TSD2b.time( 2.0 );
	$da1TSD2b.move( DOWN,128 );
	$da1TSD2c.time( 2.0 );
	$da1TSD2c.move( DOWN,128 );

	sys.wait( 2.5 );

	// Moves TSD Machine and Base up
	$da1TSD2a.time( 2 );
	$da1TSD2a.move( UP,64 );
	$da1TSD2b.time( 2 );
	$da1TSD2b.move( UP,64 );
	$da1TSD2c.time( 2 );
	$da1TSD2c.move( UP,64 );

	$da1TSD2base1a.time( 2 );
	$da1TSD2base1a.move( UP,64 );
	$da1TSD2base1a.rotateOnce( '0 360 0' );
	$da1TSD2base1b.time( 2 );
	$da1TSD2base1b.move( UP,64 );
	$da1TSD2base1c.time( 2 );
	$da1TSD2base1c.move( UP,64 );
}

void dataAnalysis1()
{
	float loopvar;
	float thread1, thread2, thread3; // Bottom machine
	float thread4, thread5, thread6; // TSD 1
	float thread7, thread8, thread9; // TSD 2

	$da1Bottompiece3bModel.bind($da1Bottompiece3b);
	$da1Bottompiece3cModel.bind($da1Bottompiece3c);
	$da1Bottompiece4bModel.bind($da1Bottompiece4b);
	$da1Bottompiece4cModel.bind($da1Bottompiece4c);
	$da1Bottompiece1Light.bind($da1Bottompiece2);

	$da1Bottompiece3f.time( 2 );
	$da1Bottompiece3g.time( 2 );
	$da1Bottompiece4f.time( 2 );
	$da1Bottompiece4g.time( 2 );

	thread1 = thread dataAnalysis1BottomFirst();
	thread4 = thread dataAnalysis1TSD1First();
	thread7 = thread dataAnalysis1TSD2First();
	sys.waitForThread( thread1 );

	while (1)
	{
		thread2 = thread dataAnalysis1BottomSecond();
		thread5 = thread dataAnalysis1TSD1Second();
		thread8 = thread dataAnalysis1TSD2Second();
		sys.waitForThread( thread2 );

		thread3 = thread dataAnalysis1BottomFirst();
		thread6 = thread dataAnalysis1TSD1First();
		thread9 = thread dataAnalysis1TSD2First();
		sys.waitForThread( thread3 );
	}
}

void dataCompressionLower()
{
	$dcLowerLightScroll1.hide();
	$dcLowerLightScroll2.hide();
	$dcLowerLightScroll3.hide();
	$dcLowerLightFlash1.hide();
	$dcLowerLightFlash2.hide();
	$dcLowerLightFlash3.hide();
	$dcLowerFx1.hide();
	$dcLowerFx2.hide();
	$dcLowerFx3.hide();

	//$dcLowerDrillbit1a.accelTime(0.2);
	//$dcLowerDrillbit1b.accelTime(0.2);
	//$dcLowerDrillbit2a.accelTime(0.2);
	//$dcLowerDrillbit2b.accelTime(0.2);
	//$dcLowerDrillbit3a.accelTime(0.2);
	//$dcLowerDrillbit3b.accelTime(0.2);

	//$dcLowerDrillbit1a.decelTime(0.2);
	//$dcLowerDrillbit1b.decelTime(0.2);
	//$dcLowerDrillbit2a.decelTime(0.2);
	//$dcLowerDrillbit2b.decelTime(0.2);
	//$dcLowerDrillbit3a.decelTime(0.2);
	//$dcLowerDrillbit3b.decelTime(0.2);

	while (1)
	{
		$dcLowerLightScroll1.show();

		sys.wait( 2 );

		$dcLowerLightScroll1.hide();
		$dcLowerLightScroll2.show();

		$dcLowerLightFlash3.hide();
		$dcLowerLightFlash1.show();

		$dcLowerFx3.hide();
		$dcLowerFx1.show();

		$dcLowerDrillbit3a.rotate( '0 0 0' );
		$dcLowerDrillbit3b.rotate( '0 0 0' );
		$dcLowerDrillbit1a.rotate( '0 720 0' );
		$dcLowerDrillbit1b.rotate( '0 -720 0' );

		sys.wait( 2 );

		$dcLowerLightScroll2.hide();
		$dcLowerLightScroll3.show();

		$dcLowerLightFlash1.hide();
		$dcLowerLightFlash2.show();

		$dcLowerFx1.hide();
		$dcLowerFx2.show();

		$dcLowerDrillbit1a.rotate( '0 0 0' );
		$dcLowerDrillbit1b.rotate( '0 0 0' );
		$dcLowerDrillbit2a.rotate( '0 720 0' );
		$dcLowerDrillbit2b.rotate( '0 -720 0' );

		sys.wait( 2 );

		$dcLowerLightScroll3.hide();

		$dcLowerLightFlash2.hide();
		$dcLowerLightFlash3.show();

		$dcLowerFx2.hide();
		$dcLowerFx3.show();

		$dcLowerDrillbit2a.rotate( '0 0 0' );
		$dcLowerDrillbit2b.rotate( '0 0 0' );
		$dcLowerDrillbit3a.rotate( '0 720 0' );
		$dcLowerDrillbit3b.rotate( '0 -720 0' );
	}
}

void dclCorridorMachine1()
{
	$dcLCorridor1.time( 6 );
	$dcLCorridor2.time( 6 );

	$dcLCorridor1.move( DOWN,416 );
	sys.wait( 4 );
	$dcLCorridor2.move( DOWN,416 );
	sys.wait( 4 );

	while (1)
	{
		$dcLCorridor1.move( UP,416 );
		sys.wait( 4 );
		$dcLCorridor2.move( UP,416 );
		sys.wait( 4 );

		$dcLCorridor1.move( DOWN,416 );
		sys.wait( 4 );
		$dcLCorridor2.move( DOWN,416 );
		sys.wait( 4 );
	}
}

void dclCorridorMachine2()
{
	$dcLCorridor3.time( 6 );
	$dcLCorridor5.time( 6 );
	$dcLCorridor4.time( 6 );
	$dcLCorridor6.time( 6 );

	$dcLCorridor3.move( DOWN,416 );
	sys.wait( 2 );
	$dcLCorridor5.move( DOWN,416 );
	sys.wait( 2 );
	$dcLCorridor4.move( DOWN,416 );
	sys.wait( 2 );
	$dcLCorridor6.move( DOWN,416 );
	sys.wait( 2 );

	while (1)
	{
		$dcLCorridor3.move( UP,416 );
		sys.wait( 2 );
		$dcLCorridor5.move( UP,416 );
		sys.wait( 2 );
		$dcLCorridor4.move( UP,416 );
		sys.wait( 2 );
		$dcLCorridor6.move( UP,416 );
		sys.wait( 2 );

		$dcLCorridor3.move( DOWN,416 );
		sys.wait( 2 );
		$dcLCorridor5.move( DOWN,416 );
		sys.wait( 2 );
		$dcLCorridor4.move( DOWN,416 );
		sys.wait( 2 );
		$dcLCorridor6.move( DOWN,416 );
		sys.wait( 2 );
	}
}

/*void rotateLasernodeElbow(entity laserNode, float rotateClockwise)	{

	//spin that laserNode round and round.

	laserNode.time(1);
	
	float fCurrentAngle = (laserNode.getFloatKey("rotValue") * 90);
	float fAxis = laserNode.getFloatKey("rotAxis");

	//get the current laser, if there is one, and shut it off.	
	entity entLaser = sys.getEntity( laserNode.getKey("activeLaser"));

	if( entLaser != $null_entity)	{
		sys.trigger(entLaser);
	}


	//spin it 90 degrees
	if (rotateClockwise)	{

		sys.println("Rotate Clockwise");

		fCurrentAngle += 90;		
		laserNode.rotateUpTo( fAxis, fCurrentAngle);
	
	} else {

		sys.println("Rotate Counter Clockwise");

		fCurrentAngle -= 90;		
		laserNode.rotateDownTo( fAxis, fCurrentAngle);

	}
	
	//store the new rotValue
	sys.waitFor(laserNode);

	if (fCurrentAngle == 360)
		fCurrentAngle = 0;

	if (fCurrentAngle < 0)
		fCurrentAngle += 360;

	laserNode.setKey("rotValue", fCurrentAngle / 90);
	sys.println("New rotValue " + (fCurrentAngle / 90));

	// turn off the impact effect to make sure it gets activated/

	//based on this rotValue, we may turn on a laser.
	entLaser = sys.getEntity( laserNode.getKey("activate_" + (fCurrentAngle / 90) ));
	
	if( entLaser != $null_entity)	{
		sys.trigger( entLaser);
		if (entLaser == $fx_laser_impact_7_a)
			effectOn($fx_laser_impact_7_a);
		laserNode.setKey( "activeLaser", entLaser.getName() );
	} else	{
		laserNode.setKey( "activeLaser", "null_entity");
	}

//	//set the impact effect
//	effectOff($fx_laser_impact_7_a);
//	if ((fCurrentAngle/90) == 0 || (fCurrentAngle/90) == 3)
//		effectOn($fx_laser_impact_7_a);

	//if we have a target, trigger it
	float t;
	for (t = 0; t < laserNode.numTargets(); t++ )	{
		sys.println("Triggering target " + t);
		laserNode.getTarget(t).activate( laserNode);
	} 

}UNUSED*/

//used for the gui that moves the first elbow.
void firstNode_left()	{	rotateNode($mvr_lasernode_pivot_1, 0);		};
void firstNode_right()	{	rotateNode($mvr_lasernode_pivot_1, 1);		};
void firstNode_null()	{			};

/*void spinThatStuff()	{

		//lower the left node
		map_process2_horseshoe::manageHorseshoeLasernodeLeft(0, 1);
		sys.wait(1);
		//spin it twice
		map_process2_horseshoe::manageHorseshoeLasernodeLeft(1, 0);
		sys.wait(1);
		map_process2_horseshoe::manageHorseshoeLasernodeLeft(1, 0);
	
	while(1)	{
		sys.wait(1);
		//rotateLasernodeElbow($mvr_lasernode_pivot_1, 1);
		//rotateLasernodeElbow($mvr_lasernode_pivot_2, 1);
		map_process2_horseshoe::manageHorseshoeLasernodeRight(0, 1);
		//sys.wait(4);
		map_process2_horseshoe::manageHorseshoeLasernodeRight(1, 0);
		//sys.wait(4);
		map_process2_horseshoe::manageHorseshoeLasernodeRight(-1, 0);
		//sys.wait(4);
		map_process2_horseshoe::manageHorseshoeLasernodeRight(0, -1);
	


	//	sys.wait(2);
	//	rotateLasernodeElbow($mvr_lasernode_pivot_1, 0);


	}

} UNUSED */

/* unused?
void checkLaserdoorOne(entity entActivator)	{
	
	sys.println("hey is this function even used?");
	//if the activator is on rotation 2, unlock the door. Otherwise, lock it. Success!
	if( entActivator.getFloatKey( "rotValue") == 2)	{
		$door_lasernode_1.lock(0);
		$door_lasernode_1.setShaderParm(7,1); // green lights
		$door_frame_1_node_puzzle.setShaderParm(7,1);
	
		//the puzzle is complete at this point.
		g_firstPuzzleComplete = 1;

		//turn turn off red, fade in regular lighting.
		sys.println("trigger light swap");
		sys.trigger($trigger_relay_5);

		//sledge wonders about the door
		aiSpeakWait( $npc_sledge, "lipsync_vo_3_1_14_120_1");

		//tether sledge back to player
		sys.trigger($ai_tether_none_firstpuzzlecomplete);

	}
	else
	{
		$door_lasernode_1.lock(1);
		$door_lasernode_1.setShaderParm(7,0); // red lights
		$door_frame_1_node_puzzle.setShaderParm(7,0);
	}
		
	//if the rot value is 1 or 3, change the effects.
	if (entActivator.getFloatKey( "rotValue") == 1 || entActivator.getFloatKey( "rotValue") == 3)	{
		sys.trigger($fx_laser_impact_7_b);
		sys.trigger($fx_laser_impact_7_a);
	}	
	
	//if it's 1 or 2, trigger the bad effect on the pipe
	if (entActivator.getFloatKey( "rotValue") == 1 || entActivator.getFloatKey( "rotValue") == 2)	{
		sys.trigger($fx_laser_impact_9_b);
	}	

	//lastly, 2 or 3, trigger the good effect over the door
	if (entActivator.getFloatKey( "rotValue") == 2 || entActivator.getFloatKey( "rotValue") == 3)	{
		sys.trigger($fx_laser_impact_9_a);
	}	

}
*/

//----------------------------------------------------------------------------------------------------------------
// Brain generation effects
//----------------------------------------------------------------------------------------------------------------

// added beam cannons for Jersey	mrenner

/*void fire_cannon_left()
{
	$laser_cannon_lf.time(.2);
	
	$laser_cannon_lf.moveTo($cannon_lf_fire);
	sys.waitFor($laser_cannon_lf);

	$laser_cannon_lf.time(.25);
	$laser_cannon_lf.accelTime(.25);

	$laser_cannon_lf.moveTo($cannon_lf_idle);

	sys.wait(6);
	$laser_cannon_lf.time(3);
	$laser_cannon_lf.decelTime(3);
	$laser_cannon_lf.moveTo($cannon_lf_fire);
} UNUSED */

/*void fire_cannon_right()
{
	$laser_cannon_rt.time(.2);
	
	$laser_cannon_rt.moveTo($cannon_rt_fire);
	sys.waitFor($laser_cannon_rt);

	$laser_cannon_rt.time(.25);
	$laser_cannon_rt.accelTime(.25);

	$laser_cannon_rt.moveTo($cannon_rt_idle);
	
	sys.wait(6);
	$laser_cannon_rt.time(3);
	$laser_cannon_rt.decelTime(3);
	$laser_cannon_rt.moveTo($cannon_rt_fire);
} UNUSED */

/*void playGenbeamEffects()	{

	//sys.println ("left generator beam");
	sys.trigger( $beam_fx_1);

// added beam cannons for Jersey	mrenner
	thread fire_cannon_left();

	$env_brainstalk_1.playEffect ("fx_brain_gen", "_rearRight_LOB", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_front_rightLob", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_Right_Lower_LOB", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_CentralRight_LOB", 1);
	
	$env_brainstalk_1.setShaderParm (6, sys.getTime());

	sys.wait (3);

	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");	

	sys.trigger( $beam_fx_1);
} UNUSED */

/*void playGenbeamEffects2()	{

	//sys.println ("right generator beam");
//	generation laser
	sys.trigger( $beam_fx_2);
	
// added beam cannons for Jersey	mrenner	
	thread fire_cannon_right();

//filler particle effects
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_rearLeft_LOB", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_front_leftLob", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_Left_Lower_LOB", 1);
	$env_brainstalk_1.playEffect ("fx_brain_gen", "_CentralLeft_LOB", 1);
	
//	brain alpha generation 
	$env_brainstalk_1.setShaderParm (5, sys.getTime());

	sys.wait (3);

//turn offfiller particle effects
	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");
	$env_brainstalk_1.stopEffect ("fx_brain_gen");	
 
	sys.trigger( $beam_fx_2);

} UNUSED */


/* void PlayElectricity ( entity fx, entity nulls )
{
	entity target;

	while ( 1 ) 
	{
		sys.wait ( sys.random ( 3 ) );

		target = nulls.randomTarget ( "" );
		fx.setKey ( "target", target.getName() );
		sys.trigger ( fx );

		sys.wait ( 2 );   // wait duration of effect +1
	}
} UNUSED */
	
/*void DoElectricityEffect ( ) 
{

		$env_brainstalk_1.playAnim ( ANIMCHANNEL_ALL, "charge");
//		aiScriptedAnimWait ( $env_brainstalk_1, "dispersal_acid_torture", 0, 1);
		//sys.println ("power up the shield!");
		
		sys.wait(1.25);
	
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_right_rear_tube", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_right_rear_tube02", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_right_front_tube", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_right_front_tube02", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_left_rear_tube", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_left_rear_tube2", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_left_front_tube", 1);
		$env_brainstalk_1.playEffect ("fx_brain_pin_ambient", "_left_front_tube2", 1);
		$env_brainstalk_1.playEffect ("fx_brain_heat", "_base_stock", 1);

	float id1;
	float id2;
	float id3;
	float id4;
	float id5;
	float id6;
	float id7;	
	float id8;
			
	id1 = thread PlayElectricity ( $elec_fx_1, $trigger_relay_left );
	id2 = thread PlayElectricity ( $elec_fx_2, $trigger_relay_left );
	id3 = thread PlayElectricity ( $elec_fx_3, $trigger_relay_left );
	id4 = thread PlayElectricity ( $elec_fx_4, $trigger_relay_left );
	id5 = thread PlayElectricity ( $elec_fx_5, $trigger_relay_right );
	id6 = thread PlayElectricity ( $elec_fx_6, $trigger_relay_right );	
	id7 = thread PlayElectricity ( $elec_fx_7, $trigger_relay_right );	
	id8 = thread PlayElectricity ( $elec_fx_8, $trigger_relay_right );
		
	sys.wait ( 8 );

	
	//sys.terminate ( id1 );
	//sys.terminate ( id2 );
	//sys.terminate ( id3 );
	//sys.terminate ( id4 );
	//sys.terminate ( id5 );
	//sys.terminate ( id6 );
	//sys.terminate ( id7 );
	//sys.terminate ( id8 );			

	//$env_brainstalk_1.stopEffect ("fx_brain_pin_ambient");
	//$env_brainstalk_1.stopEffect ("fx_brain_heat");
	
	//$env_brainstalk_1.playEffect ("fx_brain_shield", "_base_stock", 1);
	

} UNUSED */

//-------------------------------------------------------------------------------
// void activateTeleporters()
//
// Opens the teleporter pillars
//
// mrenner | Dec 2004
//-------------------------------------------------------------------------------

/*void activateTeleporters()
{
	$tele_1_wing_front.time(2);
	$tele_2_wing_front.time(2);
	$tele_3_wing_front.time(2);	
	$tele_4_wing_front.time(2);

	$tele_1_wing_back.time(2);
	$tele_2_wing_back.time(2);
	$tele_3_wing_back.time(2);	
	$tele_4_wing_back.time(2);
		
	$tele_1_wing_front.accelTime(1);
	$tele_2_wing_front.accelTime(1);
	$tele_3_wing_front.accelTime(1);
	$tele_4_wing_front.accelTime(1);

	$tele_1_wing_back.accelTime(1);
	$tele_2_wing_back.accelTime(1);	
	$tele_3_wing_back.accelTime(1);	
	$tele_4_wing_back.accelTime(1);		
	
	$tele_1_wing_front.rotateOnce( '-104 0 0' );
	$tele_1_wing_back.rotateOnce( '-104 0 0' );
	$tele_2_wing_front.rotateOnce( '-104 0 0' );
	$tele_2_wing_back.rotateOnce( '-104 0 0' );
	$tele_3_wing_front.rotateOnce( '-104 0 0' );
	$tele_3_wing_back.rotateOnce( '-104 0 0' );
	$tele_4_wing_front.rotateOnce( '-104 0 0' );
	$tele_4_wing_back.rotateOnce( '-104 0 0' );
} UNUSED */

/*void beams_teleporters()
{
	//beam on! this should run them both together.
	thread playGenbeamEffects();
	playGenbeamEffects2();

	thread DoElectricityEffect();

	sys.wait(5);
	
	// open the teleporter pillars		mrenner
	thread activateTeleporters();
	sys.wait(3);

	//start spawning in dudes.
	sys.trigger($brain_spawner);
} UNUSED */

/*void iris_close()
{
	$iris_1.time(5);
	$iris_2.time(5);
	$iris_3.time(5);
	$iris_4.time(5);	
	$iris_5.time(5);
	$iris_6.time(5);
	$iris_7.time(5);
	$iris_8.time(5);	
	
	$iris_1.decelTime(4);
	$iris_2.decelTime(4);
	$iris_3.decelTime(4);
	$iris_4.decelTime(4);
	$iris_5.decelTime(4);
	$iris_6.decelTime(4);
	$iris_7.decelTime(4);
	$iris_8.decelTime(4);

	$iris_5.rotateOnce( '-90 0 0');
	$iris_6.rotateOnce( '-90 0 0');
	$iris_7.rotateOnce( '-90 0 0');
	$iris_8.rotateOnce( '-90 0 0');	

	sys.wait(1);

	$iris_1.rotateOnce( '90 0 0');
	$iris_2.rotateOnce( '90 0 0');
	$iris_3.rotateOnce( '90 0 0');
	$iris_4.rotateOnce( '90 0 0');	
	sys.waitFor($iris_4);
	
	$iris_5.hide();
	$iris_6.hide();	
	$iris_7.hide();
	$iris_8.hide();		
} UNUSED */

/*void iris_setup()
{
	$iris_1.speed(.1);
	$iris_2.speed(.1);
	$iris_3.speed(.1);
	$iris_4.speed(.1);	
	$iris_5.speed(.1);
	$iris_6.speed(.1);
	$iris_7.speed(.1);
	$iris_8.speed(.1);	

	$iris_1.rotateOnce( '-90 0 0');
	$iris_2.rotateOnce( '-90 0 0');
	$iris_3.rotateOnce( '-90 0 0');
	$iris_4.rotateOnce( '-90 0 0');	
	$iris_5.rotateOnce( '90 0 0');
	$iris_6.rotateOnce( '90 0 0');
	$iris_7.rotateOnce( '90 0 0');
	$iris_8.rotateOnce( '90 0 0');	
} UNUSED */

/*void brain_swap()
{
	$spine.hide();
	$crown_left.hide();
	$crown_right.hide();
	$crown_bttm_01.hide();
	$crown_bttm_02.hide();

	$env_brainstalk_1.show();
} UNUSED */

/*void crown_bottom()
{
	$origin_crown_bttm_01.time(1);
	$origin_crown_bttm_02.time(1);	

	$origin_crown_bttm_01.decelTime(1);
	$origin_crown_bttm_02.decelTime(1);
	
	$origin_crown_bttm_01.rotateOnce( '0 0 -50' );
	sys.waitFor($origin_crown_bttm_01);
	sys.wait(.25);
	$origin_crown_bttm_02.rotateOnce( '0 0 -60' );
} UNUSED */

/*void spine_up()
{
	$spine.time(3);
	$spine.decelTime(2);

	$spine_turn.time(3);
	$spine_turn.decelTime(2);
	
	$spine.move( UP,800 );
	$spine.rotateOnce( '0 720 0' );	
} UNUSED */

/*void crown_top()
{
	thread spine_up();
	sys.wait(1.5);
	
	$piston_crown_right.time(1);
	$piston_crown_left.time(1);	
	$origin_crown_right.time(1);
	$origin_crown_left.time(1);	
	
	$laser_cannon_rt.time(2);
	$laser_cannon_lf.time(2);

	$piston_crown_right.decelTime(1);
	$piston_crown_left.decelTime(1);
	$origin_crown_right.decelTime(1);
	$origin_crown_left.decelTime(1);

	$laser_cannon_rt.decelTime(1);
	$laser_cannon_lf.decelTime(1);
	$laser_cannon_rt.accelTime(1);
	$laser_cannon_lf.accelTime(1);

	$piston_crown_right.move( DOWN,484 );
	$piston_crown_left.move( DOWN,484 );
	sys.waitFor($piston_crown_left);

	$piston_crown_right.move( EAST,72 );
	$piston_crown_left.move( WEST,72 );
	sys.waitFor($piston_crown_right);

	thread crown_bottom();
	
	$piston_crown_right.move( SOUTH,48 );
	$origin_crown_right.rotateOnce( '0 0 30' );
	$origin_crown_left.rotateOnce( '0 0 30' );
	sys.waitFor($piston_crown_right);

	$laser_cannon_rt.moveTo($cannon_rt_idle);
	$laser_cannon_lf.moveTo($cannon_lf_idle);
	
	$origin_crown_right.rotateOnce( '75 0 0' );
	$origin_crown_left.rotateOnce( '-75 0 0' );
	$piston_crown_right.move( UP,64 );
	$piston_crown_left.move( UP,64 );
	sys.waitFor($origin_crown_right);
	
	thread brain_swap();
	sys.wait(.5);
	thread beams_teleporters();
} UNUSED*/

/*void brain_setup()
{
	$origin_crown_bttm_01.time(.1);
	$origin_crown_bttm_02.time(.1);
		
	$origin_crown_bttm_01.rotateOnce( '0 0 50' );
	$origin_crown_bttm_02.rotateOnce( '0 0 60' );

	$origin_crown_right.time(.1);
	$origin_crown_left.time(.1);
	$piston_crown_right.time(.1);
	$piston_crown_left.time(.1);

	$spine.time(.1);
	$spine.move( DOWN,800 );

	$piston_crown_right.move( UP,420 );
	$piston_crown_left.move( UP,420 );

	$origin_crown_right.rotateOnce( '0 0 -30' );
	$origin_crown_left.rotateOnce( '0 0 -30' );
	sys.waitFor($origin_crown_right);
	$origin_crown_right.rotateOnce( '-75 0 0' );
	$origin_crown_left.rotateOnce( '75 0 0' );
	
	$piston_crown_right.move( NORTH,48 );
	sys.waitFor($piston_crown_right);
	$piston_crown_right.move( WEST,72 );
	$piston_crown_left.move( EAST,72 );
} UNUSED*/

//-------------------------------------------------------------------------------
// void activateBrain()
//
// Powers up the brain, and starts all hell breaking loose
//
// jshepard | Dec 2004
//-------------------------------------------------------------------------------
/*void activateBrain()
{
	sys.println("void activateBrain::begin");

	$door_brain_room.lock(1);

	thread iris_close();
	sys.wait(6.5);
	thread crown_top();
	
	//sys.println("void activateBrain::end");

} UNUSED */

//the end of the brain room
/*void brainEnd()	{

	$door_brain_room.lock(0);
	sys.trigger( $radio_strassa_brain_3);
	sys.trigger( $complete_objective_brain);
	sys.trigger( $tgr_brainroom_over);
	
// there isn't a level transistion now.
//	sys.trigger( $tgr_endlevel);
} UNUSED */

//events after the brain room
/*void brainRoomOver()	{

	//sys.println("brainRoomOver::begin");

	//unbind sledge
	$npc_sledge.unbind();

	//have him say his piece.
	aiSpeakWait( $npc_sledge, "lipsync_vo_3_1_14_280_1");

	//go to the end sledge
	aiScriptedMove( $npc_sledge, $tgt_sledge_endlevel, 1, 1);
} UNUSED */

void guiElevatorUp()	{

	//raise the count in the elevator gui
	float fFloor = 1967;
	float fWaitTime = 1.5;
	
	//count up
	while (fFloor < 1987)	{

		$gui_in_elevator.setGuiParm("floorNumber", fFloor );
		$gui_in_elevator.guiEvent("changeFloor");
	
		fFloor++;

		//slow down as we approach our destination.
		if( fFloor > 1980)	{
			fWaitTime *= 1.05;
		}

		sys.wait(fWaitTime);
	}
	
	sys.wait(1);

	g_introElevatorDone = 1;
}

//turn lights on in lower area in sequence
void lowerAreaLightsOn()
{
	$npc_sledge.setKey( "allowPlayerPush", "1" );
	
	sys.trigger($light_8253);
	sys.trigger($speaker_lightson_1);
	
	sys.wait(.5);
	sys.trigger($light_8249);
	sys.trigger($speaker_lightson_2);

	sys.wait(.5);
	sys.trigger($light_8254);
	sys.trigger($speaker_lightson_2);
	
	sys.wait(.5);
	sys.trigger($light_8258);
	sys.trigger($light_8264);
}

void repairNode( entity bot , entity moveNode, entity lookNode )	{
	
	if( isValidEntity( bot ) )	{
	
		aiScriptedMoveWait( bot , moveNode , 8 , 1 );
		
		if( isValidEntity( bot ) )	{
			aiScriptedFaceWait( bot , lookNode , 1 );
			
			if (isValidEntity( bot ) )	{
				aiScriptedActionWait( bot , moveNode , 	1 );		
			}
		}	
	}
}

void botRepairsNodes( entity bot )	{

	while( isValidEntity( bot ))	{
	
		if ( isValidEntity( bot ) )	{
			repairNode ( bot , $node_bot_a_spot_1 , $node_bot_a_look );
		}
		sys.waitFrame();
			
		if ( isValidEntity( bot ) )	{
			repairNode ( bot , $node_bot_a_spot_2 , $node_bot_a_look );
		}
		sys.waitFrame();

		if ( isValidEntity( bot ) )	{
			repairNode ( bot , $node_bot_a_spot_3 , $node_bot_a_look );
		}
		sys.waitFrame();
		
		if ( isValidEntity( bot ) )	{
			repairNode ( bot , $node_bot_a_spot_2 , $node_bot_a_look );
		}
		sys.waitFrame();

	}
}

void talkAboutBeams()
{
	// aiScriptedAnimWait( $npc_sledge, "point_up", 3, 1);
	
	$npc_sledge.lookAt($sledge_look_up);
	sys.wait(1.5);

	// No reason for this, it'll just make bad things happen with the com link anims.
	//$npc_sledge.lookAt($player1);
	//sys.wait(1);
	
	aiScriptedAnimWait( $npc_sledge, "com_link_start", 16, 0);
	aiScriptedAnimLoop( $npc_sledge, "com_link_loop", 4 );
	aiSpeakWait( $npc_sledge, "lipsync_vo_3_1_14_110_1"); 
	aiScriptedAnimWait( $npc_sledge, "com_link_end", 8, 1); //return to idle so ai can pick up tether

	//tether just off of elevator and wait for player
	sys.trigger($ai_tether_radius_sledge_intro);
	
	//it looks silly when Sledge keeps looking up at these while he's walking.
	$npc_sledge.lookAt($null_entity );

	//answer beam question, give objective, and then clarify beams.
	sys.trigger($radio_strauss_answer_beam_question);
	sys.wait(8);
	sys.trigger($objective_alignnodes);
	sys.wait(1.5);
	sys.trigger($radio_strauss_answer_beam_question_continued);

}

//added for more interesting sledge action in intro elevator -corey

void sledgeLookAround1()
{
	$npc_sledge.lookAt($sledge_look_around_1);
	sys.wait(3);
	// aiSpeak($npc_sledge, "lipsync_vo_3_1_14_105_2");
	sys.wait(1.5);
	$npc_sledge.lookAt($player1);
}

void sledgeFidget1()
{
	sys.wait(2);
	// aiSpeak($npc_sledge, "lipsync_vo_3_1_14_105_1");
	sys.wait(2.5);
	
	// Fix for evil eye badness
	$npc_sledge.lookAt( $null_entity );
	
	//play anims
	aiScriptedAnimWait($npc_sledge, "idle_look_back_lt", 8, 0);
	aiScriptedAnimWait($npc_sledge, "weapon_check_1", 16, 1);
	
	// return eye focus
	$npc_sledge.lookAt( $player1 );
}

void radioChatter1()
{
	sys.trigger($radio_chatter_1);
	sys.wait(6.5);
	aiSpeak($npc_sledge, "lipsync_vo_3_1_14_115_2");
}

void talkAbout8nodePuzzle()
{
	$npc_sledge.lookAt($null_entity);
	aiSpeakWait( $npc_sledge, "lipsync_vo_3_1_14_170_1");
}

void straussIsImpatient()
{
	sys.wait(300); // five minutes
	if ($door_typical_131.getFloatKey("locked") > 0) // if the first puzzle still isn't solved
		sys.trigger($radio_strauss_hurry_up);
}

void moveElevator()  
{
	// move the elevator at the start of the level. there is a light bound to it along with the floor countdown gui - jersey
	$intro_elevator.time(32);
	$intro_elevator.decelTime(2);
	$intro_elevator.moveTo($intro_elevator_stop);
}

void dropCaskets1()
{
	$func_mover_casketcontrol_1.move(-2,128);
	$func_mover_casketcontrol_2.move(-2,128);
	
	sys.trigger($tuberoom_light_1);
	sys.trigger($tuberoom_light_2);
	
	sys.waitFor($func_mover_casketcontrol_1);
	sys.trigger($env_wall_casket_noderoom_1);
	sys.trigger($monster_iron_maiden_noderoom_1);
	sys.trigger($env_wall_casket_noderoom_2);
	sys.trigger($monster_iron_maiden_noderoom_2);
	
	$eastAlcoveSentry.remove();
	$northAlcoveSentry.remove();
	$westAlcoveSentry.remove();
}

//Intro to the level-- moving the elevator up, playing the right VO, and getting good to go.
void levelIntro()	
{
	$npc_sledge.lookAt($player1);
	sys.fadeIn('0 0 0', 3);

	//UP!
	thread guiElevatorUp();
	thread moveElevator();

	//wait a couple of seconds.
	//sys.wait(3);

	//play the radio chatter
	//sys.trigger($radio_strassa_intro);  This has been cut from the script

	//wait until the elevator is up
	while(g_introElevatorDone == 0)	{
		sys.waitFrame();
	}
}

void firstLockedDoorCombatComplete()
{
	aiSpeak($npc_sledge, "lipsync_vo_9_6_90_6" );
	$func_static_54317.setGuiParm( "noninteractive", "0" );
}

//in lower area sledge encounters a locked door
void firstLockedDoor()
{	
	aiScriptedAnimWait( $npc_sledge, "com_link_start", 16, 1);
	aiScriptedAnimLoop( $npc_sledge, "com_link_loop", 4 );
	aiSpeakWait( $npc_sledge, "lipsync_vo_3_1_14_175_1");
	aiScriptedAnimWait( $npc_sledge, "com_link_end", 8, 1);
	
	//strauss - "there is nothing I can do"
	sys.wait(1);
	sys.trigger($func_radiochatter_1);
}

/* ai_trigger added to control this -corey
//called when a baddie is dropped in the first puzzle room.
void firstPuzzleBaddieKill()	
{
	g_firstPuzzleBaddiesKilled++;
}
*/


//prepares sledge for the stuff he says in the first puzzle.
//void firstPuzzleSledge()	{
	
/* ai_trigger added to control this -corey
	//do nothing until the baddies in this room are cleared.
	while (g_firstPuzzleBaddiesKilled != 5)	{
		sys.wait(1);
	}
*/

	//announce that this function is rollin
//	sys.println("Baddies cleared out.");

	//move to his position by the gui
	//tether replaces this -corey
	//aiScriptedMove( $npc_sledge, $tgt_sledge_firstgui, 1, 1);

//	sys.wait(2);

	//strassa jive
	//sys.trigger($radio_strassa_puzzle_1); This no longer exists

	//wait until the player completes the puzzle
//	while (	g_firstPuzzleComplete == 0)	{
//		sys.wait(1);
//	}
// from here on down doesn't work for some reason, and the VO is called twice. commented out. -corey
//	sys.println("Puzzle complete: speak sledge!");

	//have sledge say something cool
//	aiSpeak( $npc_sledge, "lipsync_vo_3_1_14_120_1" );
	
	//make sledge follow the player again
//	sys.trigger($ai_tether_none_firstpuzzlecomplete);

//}

/* removed, set undying on sledge. -corey
void maintainSledge()	{
	while(1)	{
		$npc_sledge.setHealth(500);
		sys.wait(0.5);
	}
}
*/
// Message from dragon squad to Sledge.
/*void dragonRadio()	{

	//wait a bit
	sys.wait(4);

	//play the message
	sys.trigger( $radio_dragon_1);
	sys.wait(7);

	//sledge replies
	aiSpeak( $npc_sledge, "lipsync_vo_3_1_14_190_2");

} UNUSED */

//Strassa's radio message and the objective.
/*void strassaObjective()	{

	//wait a couple ticks
	sys.wait(3 + sys.random(2));
	
	//strassa in
	sys.trigger( $radio_strassa_describe_objective);
	sys.wait(14);

	//objective
	sys.trigger( $objective_brainroom);

	//sledge replies
	aiSpeak( $npc_sledge, "lipsync_vo_3_1_14_195_2");	

} UNUSED */

//if the beam on the roof hasn't been activated, the elevator out doesn't work
//SCRIPT CHANGE -beam is active at all times. this script does nothing.

void elevatorBusta()	
{
	$npc_sledge.setKey( "allowPlayerPush", "1" );
	
	if( g_activateBeamComplete == 0)	{
		aiScriptedMoveWait( $npc_sledge, $tgt_elevator_busta, 1, 1);
		aiSpeak( $npc_sledge, "lipsync_vo_3_1_14_198_1");
	}
}


//prepares the player for brain room entry
/*void preBrainRoom()	{
	
	//strassa needs to talk about how cool the brain is
	sys.trigger( $radio_strassa_brain_1);

	//start moving sledge to his position
	aiScriptedMoveWait( $npc_sledge, $tgt_sledge_waitforbrain, 1, 1);
	$npc_sledge.bind( $tgt_sledge_waitforbrain);
	
	//sledge says he can't go with you
	sys.wait(3);
	
	aiSpeak( $npc_sledge, "lipsync_vo_3_1_14_200_1");
	$door_brain_room.lock(0);


} UNUSED */

// rotates the elevator to the other side of the main shaft
void turnElevator()
{
	// disable the elevator's gui so that the user doesn't move the elevator down while it's rotating
	$func_elevator_29.setKey("gui_parm_disable", "1"); // the gui can't be clicked until this is set back to 0

	sys.wait(2);

	$elevatorPivot.time(6);
	$elevatorPivot.accelTime(2);
	$elevatorPivot.decelTime(3);

	// $npc_sledge.bind($elevatorPivot);
	
	$elevatorPivot.rotateOnce( '0 180 0' );
	sys.waitFor($elevatorPivot);
	// $npc_sledge.unbind();
	// cancels out the tether that sledge is bound to on the elevator - jersey
	sys.trigger ($sledge_tether_none_elevator);
	
	//enables callback GUI
	$rotate_lift_callback.guiEvent ( "reset" );
	$func_elevator_29.setGuiParm( "noninteractive", "1" );
	

}

/*
void sledgeOnRoofElevator()
{
	// For some reason, Sledge causes the elevator to bounce off of the aas obstacle at the top.  This is a hack to fix it.
	$npc_sledge.bind($func_elevator_34);
	sys.waitFor($func_elevator_34);
	$npc_sledge.unbind();
}
*/

void initLaserPuzzle()
{
	// the effects must be bound by position (not orientation) or they will not play in the right direction (seems this is no longer true 5/9/05 gc)
	$fx_lasernodeA1_input1.bind( $mvr_lasernodeA1_pivot);
	$fx_lasernodeA1_input2.bind( $mvr_lasernodeA1_pivot);
	$fx_laserimpactA1_1.bind( $mvr_lasernodeA1_pivot);
	$fx_laserimpactA1_2.bind( $mvr_lasernodeA1_pivot);

	$fx_lasernodeA2_input1.bind( $mvr_lasernodeA2_pivot);
	$fx_lasernodeA2_input2.bind( $mvr_lasernodeA2_pivot);
	$fx_laserimpactA2_1.bind( $mvr_lasernodeA2_pivot);
	$fx_laserimpactA2_2.bind( $mvr_lasernodeA2_pivot);

	$fx_lasernodeA3_input1.bind( $mvr_lasernodeA3_pivot);
	$fx_lasernodeA3_input2.bind( $mvr_lasernodeA3_pivot);
	$fx_laserimpactA3_1.bind( $mvr_lasernodeA3_pivot);
	$fx_laserimpactA3_2.bind( $mvr_lasernodeA3_pivot);

	$fx_lasernodeB1_input1.bind( $mvr_lasernodeB1_pivot);
	$fx_lasernodeB1_input2.bind( $mvr_lasernodeB1_pivot);
	$fx_laserimpactB1_1.bind( $mvr_lasernodeB1_pivot);
	$fx_laserimpactB1_2.bind( $mvr_lasernodeB1_pivot);

	$fx_lasernodeB3_input1.bind( $mvr_lasernodeB3_pivot);
	$fx_lasernodeB3_input2.bind( $mvr_lasernodeB3_pivot);
	$fx_laserimpactB3_1.bind( $mvr_lasernodeB3_pivot);
	$fx_laserimpactB3_2.bind( $mvr_lasernodeB3_pivot);

	$fx_lasernodeC1_input1.bind( $mvr_lasernodeC1_pivot);
	$fx_lasernodeC1_input2.bind( $mvr_lasernodeC1_pivot);
	$fx_laserimpactC1_1.bind( $mvr_lasernodeC1_pivot);
	$fx_laserimpactC1_2.bind( $mvr_lasernodeC1_pivot);

	$fx_lasernodeC2_input1.bind( $mvr_lasernodeC2_pivot);
	$fx_lasernodeC2_input2.bind( $mvr_lasernodeC2_pivot);
	$fx_laserimpactC2_1.bind( $mvr_lasernodeC2_pivot);
	$fx_laserimpactC2_2.bind( $mvr_lasernodeC2_pivot);

	$fx_lasernodeC3_input1.bind( $mvr_lasernodeC3_pivot);
	$fx_lasernodeC3_input2.bind( $mvr_lasernodeC3_pivot);
	$fx_laserimpactC3_1.bind( $mvr_lasernodeC3_pivot);
	$fx_laserimpactC3_2.bind( $mvr_lasernodeC3_pivot);

	// make sure each node takes one second when it turns
	$mvr_lasernodeA1_pivot.time(1);
	$mvr_lasernodeA2_pivot.time(1);
	$mvr_lasernodeA3_pivot.time(1);
	$mvr_lasernodeB1_pivot.time(1);
	$mvr_lasernodeB3_pivot.time(1);
	$mvr_lasernodeC1_pivot.time(1);
	$mvr_lasernodeC2_pivot.time(1);
	$mvr_lasernodeC3_pivot.time(1);
}

// function to initialize the 16-node puzzle
/*void init20nodes()
{
	// the effects must be bound by position (not orientation) or they will not play in the right direction

	$fx_input_A1_top_1.bindPosition( $mvr_node_pivot_A1_top );
	$fx_input_A1_top_2.bindPosition( $mvr_node_pivot_A1_top );
	$fx_impact_A1_top_1.bindPosition( $mvr_node_pivot_A1_top );
	$fx_impact_A1_top_2.bindPosition( $mvr_node_pivot_A1_top );

	$fx_input_A2_top_1.bindPosition( $mvr_node_pivot_A2_top );
	$fx_input_A2_top_2.bindPosition( $mvr_node_pivot_A2_top );
	$fx_impact_A2_top_1.bindPosition( $mvr_node_pivot_A2_top );
	$fx_impact_A2_top_2.bindPosition( $mvr_node_pivot_A2_top );

	$fx_input_A3_top_1.bindPosition( $mvr_node_pivot_A3_top );
	$fx_input_A3_top_2.bindPosition( $mvr_node_pivot_A3_top );
	$fx_impact_A3_top_1.bindPosition( $mvr_node_pivot_A3_top );
	$fx_impact_A3_top_2.bindPosition( $mvr_node_pivot_A3_top );

	$fx_input_B1_top_1.bindPosition( $mvr_node_pivot_B1_top );
	$fx_input_B1_top_2.bindPosition( $mvr_node_pivot_B1_top );
	$fx_impact_B1_top_1.bindPosition( $mvr_node_pivot_B1_top );
	$fx_impact_B1_top_2.bindPosition( $mvr_node_pivot_B1_top );

	$fx_input_B3_top_1.bindPosition( $mvr_node_pivot_B3_top );
	$fx_input_B3_top_2.bindPosition( $mvr_node_pivot_B3_top );
	$fx_impact_B3_top_1.bindPosition( $mvr_node_pivot_B3_top );
	$fx_impact_B3_top_2.bindPosition( $mvr_node_pivot_B3_top );

	$fx_input_C1_top_1.bindPosition( $mvr_node_pivot_C1_top );
	$fx_input_C1_top_2.bindPosition( $mvr_node_pivot_C1_top );
	$fx_impact_C1_top_1.bindPosition( $mvr_node_pivot_C1_top );
	$fx_impact_C1_top_2.bindPosition( $mvr_node_pivot_C1_top );

	$fx_input_C3_top_1.bindPosition( $mvr_node_pivot_C3_top );
	$fx_input_C3_top_2.bindPosition( $mvr_node_pivot_C3_top );
	$fx_impact_C3_top_1.bindPosition( $mvr_node_pivot_C3_top );
	$fx_impact_C3_top_2.bindPosition( $mvr_node_pivot_C3_top );

	$fx_input_D1_top_1.bindPosition( $mvr_node_pivot_D1_top );
	$fx_input_D1_top_2.bindPosition( $mvr_node_pivot_D1_top );
	$fx_impact_D1_top_1.bindPosition( $mvr_node_pivot_D1_top );
	$fx_impact_D1_top_2.bindPosition( $mvr_node_pivot_D1_top );

	$fx_input_D2_top_1.bindPosition( $mvr_node_pivot_D2_top );
	$fx_input_D2_top_2.bindPosition( $mvr_node_pivot_D2_top );
	$fx_impact_D2_top_1.bindPosition( $mvr_node_pivot_D2_top );
	$fx_impact_D2_top_2.bindPosition( $mvr_node_pivot_D2_top );

	$fx_input_D3_top_1.bindPosition( $mvr_node_pivot_D3_top );
	$fx_input_D3_top_2.bindPosition( $mvr_node_pivot_D3_top );
	$fx_impact_D3_top_1.bindPosition( $mvr_node_pivot_D3_top );
	$fx_impact_D3_top_2.bindPosition( $mvr_node_pivot_D3_top );

	$fx_input_A1_bottom_1.bindPosition( $mvr_node_pivot_A1_bottom );
	$fx_input_A1_bottom_2.bindPosition( $mvr_node_pivot_A1_bottom );
	$fx_impact_A1_bottom_1.bindPosition( $mvr_node_pivot_A1_bottom );
	$fx_impact_A1_bottom_2.bindPosition( $mvr_node_pivot_A1_bottom );

	$fx_input_A2_bottom_1.bindPosition( $mvr_node_pivot_A2_bottom );
	$fx_input_A2_bottom_2.bindPosition( $mvr_node_pivot_A2_bottom );
	$fx_impact_A2_bottom_1.bindPosition( $mvr_node_pivot_A2_bottom );
	$fx_impact_A2_bottom_2.bindPosition( $mvr_node_pivot_A2_bottom );

	$fx_input_A3_bottom_1.bindPosition( $mvr_node_pivot_A3_bottom );
	$fx_input_A3_bottom_2.bindPosition( $mvr_node_pivot_A3_bottom );
	$fx_impact_A3_bottom_1.bindPosition( $mvr_node_pivot_A3_bottom );
	$fx_impact_A3_bottom_2.bindPosition( $mvr_node_pivot_A3_bottom );

	$fx_input_B1_bottom_1.bindPosition( $mvr_node_pivot_B1_bottom );
	$fx_input_B1_bottom_2.bindPosition( $mvr_node_pivot_B1_bottom );
	$fx_impact_B1_bottom_1.bindPosition( $mvr_node_pivot_B1_bottom );
	$fx_impact_B1_bottom_2.bindPosition( $mvr_node_pivot_B1_bottom );

	$fx_input_B3_bottom_1.bindPosition( $mvr_node_pivot_B3_bottom );
	$fx_input_B3_bottom_2.bindPosition( $mvr_node_pivot_B3_bottom );
	$fx_impact_B3_bottom_1.bindPosition( $mvr_node_pivot_B3_bottom );
	$fx_impact_B3_bottom_2.bindPosition( $mvr_node_pivot_B3_bottom );

	$fx_input_C1_bottom_1.bindPosition( $mvr_node_pivot_C1_bottom );
	$fx_input_C1_bottom_2.bindPosition( $mvr_node_pivot_C1_bottom );
	$fx_impact_C1_bottom_1.bindPosition( $mvr_node_pivot_C1_bottom );
	$fx_impact_C1_bottom_2.bindPosition( $mvr_node_pivot_C1_bottom );

	$fx_input_C3_bottom_1.bindPosition( $mvr_node_pivot_C3_bottom );
	$fx_input_C3_bottom_2.bindPosition( $mvr_node_pivot_C3_bottom );
	$fx_impact_C3_bottom_1.bindPosition( $mvr_node_pivot_C3_bottom );
	$fx_impact_C3_bottom_2.bindPosition( $mvr_node_pivot_C3_bottom );

	$fx_input_D1_bottom_1.bindPosition( $mvr_node_pivot_D1_bottom );
	$fx_input_D1_bottom_2.bindPosition( $mvr_node_pivot_D1_bottom );
	$fx_impact_D1_bottom_1.bindPosition( $mvr_node_pivot_D1_bottom );
	$fx_impact_D1_bottom_2.bindPosition( $mvr_node_pivot_D1_bottom );

	$fx_input_D2_bottom_1.bindPosition( $mvr_node_pivot_D2_bottom );
	$fx_input_D2_bottom_2.bindPosition( $mvr_node_pivot_D2_bottom );
	$fx_impact_D2_bottom_1.bindPosition( $mvr_node_pivot_D2_bottom );
	$fx_impact_D2_bottom_2.bindPosition( $mvr_node_pivot_D2_bottom );

	$fx_input_D3_bottom_1.bindPosition( $mvr_node_pivot_D3_bottom );
	$fx_input_D3_bottom_2.bindPosition( $mvr_node_pivot_D3_bottom );
	$fx_impact_D3_bottom_1.bindPosition( $mvr_node_pivot_D3_bottom );
	$fx_impact_D3_bottom_2.bindPosition( $mvr_node_pivot_D3_bottom );

} UNUSED */
	
// Rotate the Iron Maiden stuff to the correct angle at map load (threaded in Main)
void prepareMaidenCasket()	{

	$maidenRise.time( .1 );
	$maidenSpinnerB.time( .1 );
	$maidenRise.move( DOWN , 192 );
	$maidenSpinnerB.rotateOnce( '-45 0 0' );

}

// brings out the iron maiden in the middle of the 8-node puzzle
void ironMaidenAttack() 
{
	// open the trap doors
	$mvr_trap_door_left.time(.5);
	$mvr_trap_door_right.time(.5);
	$mvr_trap_door_left.move(270, 112);
	$mvr_trap_door_right.move(90, 112);
	sys.trigger($spkr_iron_maiden_trapdoors);
	
	// raise the central pillar
	$maidenRise.time( 3 );
	$maidenRise.accelTime( .5 );
	$maidenRise.decelTime( 1 );
	$maidenRise.move( UP , 192 );
	sys.trigger($spkr_maiden_trap_raise);
	sys.waitFor( $maidenRise );
	
	// Wait a sec (literally) to spring the surprise!
	sys.wait( 1 );

	// Set casket rotation times
	$maidenSpinner.time( 2 );
	$maidenSpinner.accelTime( 1 );
	$maidenSpinner.decelTime( .5 );
	
	$maidenSpinnerB.time( 1 );
	$maidenSpinnerB.accelTime( .5 );
	$maidenSpinnerB.decelTime( .2 );
	
	// Rotate entire piece
	$maidenSpinner.rotateOnce( '0 180 0' );
	sys.trigger($spkr_maiden_trap_rotate);
	
	// Wait half a second, then bring maiden casket up to proper rotated position
	sys.wait( 1 );
	$maidenSpinnerB.rotateOnce( '45 0 0' );
	sys.waitFor( $maidenSpinnerB );

	// open the casket
	//sys.println("triggering casket");
	sys.trigger($casket_8node_trap);
    
	// make the iron maiden visible
	//sys.println("triggering maiden");
	sys.trigger($iron_maiden_8node_trap);
	$casket_8node_trap.hideSurface( "models/monsters/iron_maiden/base" );

	// wait, then lower the casket
	sys.wait(1);
	$maidenRise.time(3);
	$maidenRise.accelTime(.5);
	$maidenRise.decelTime(.5);
	sys.trigger($spkr_maiden_trap_raise);
	$maidenRise.move(DOWN, 96);

	thread straussIsImpatient(); // start the timer for strauss complaining
}

// this takes care of the lighting change in the node puzzle area

void puzzle_light_switch ()
{
	
	sys.trigger ($node_fog_under_light);
	sys.trigger ($node_lights_fade_sound);
				
	// the red light underneath the maiden casket as it goes round
	sys.trigger($node_maiden_red_light);
		
	// the project and fill lights along the outer rim of the puzzle area
	$node_right_side_a.fadeOutLight(3);
	$node_right_side_b.fadeOutLight(3);
	$node_right_side_c.fadeOutLight(3);
	$node_right_side_a_fill.fadeOutLight(3);
	$node_right_side_b_fill.fadeOutLight(3);
	$node_right_side_c_fill.fadeOutLight(3);
	
	//$node_left_side_a.fadeOutLight(3);
	$node_left_side_b.fadeOutLight(3);
	$node_left_side_c.fadeOutLight(3);
	//$node_left_side_a_fill.fadeOutLight(3);
	$node_left_side_b_fill.fadeOutLight(3);
	$node_left_side_c_fill.fadeOutLight(3);
}

// cpeters: added following three functions for laser puzzle 2/15/04
// open windows surrounding laser puzzle
void openWindows() 
{
	puzzle_light_switch();
	sys.trigger($node_upper_door);

	// section has portals that need to be turned off manually - jersey 
	sys.trigger ($node_east_portal);
	sys.trigger ($node_west_portal);
	sys.trigger ($node_north_portal);
	sys.trigger ($node_south_portal);

	$func_mover_window_1.move(-2, 176);
	$func_mover_window_2.move(-2, 176);
	$func_mover_window_3.move(-2, 176);
	$func_mover_window_4.move(-2, 176);	
}

void raise8NodePuzzle()
{
	if (g_puzzleReady > 0)
		return; // only need to do this once

	if ($node_case_1.getFloatKey("nodeCaseCheck") == 0)
		return; // need to raise the glass and cases first

	g_puzzleReady = 1;
	
	// MOVING THIS BECAUSE IT LOOKS BAD WHEN A MAIDEN COMPLETELY CLIPS THROUGH THE NODES
	// set off the iron maiden trap
	ironMaidenAttack();

	$mvr_lasernodeA1_pivot.time(4);
	$mvr_lasernodeA2_pivot.time(4);
	$mvr_lasernodeA3_pivot.time(4);
	$mvr_lasernodeB1_pivot.time(4);
	$mvr_lasernodeB3_pivot.time(4);
	$mvr_lasernodeC1_pivot.time(4);
	$mvr_lasernodeC2_pivot.time(4);
	$mvr_lasernodeC3_pivot.time(4);
	
	// turns on the lights above the node stuff
	sys.trigger($node_main_light);
	sys.trigger ($node_main_light_sound);
	sys.trigger($node_main_light_upper_left);
	sys.trigger($node_main_light_upper_right);


    	// raise each laser node, doing one complete rotation on the way up

	$mvr_lasernodeC1_pivot.moveTo($tgt_move_here_C1);
	$mvr_lasernodeC1_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeC1_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	sys.wait(.5);
	$mvr_lasernodeC3_pivot.moveTo($tgt_move_here_C3);
	$mvr_lasernodeC3_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeC3_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	$mvr_lasernodeB3_pivot.moveTo($tgt_move_here_B3);
	$mvr_lasernodeB3_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeB3_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	sys.wait(.5);
	$mvr_lasernodeA3_pivot.moveTo($tgt_move_here_A3);
	$mvr_lasernodeA3_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeA3_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	$mvr_lasernodeB1_pivot.moveTo($tgt_move_here_B1);
	$mvr_lasernodeB1_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeB1_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	sys.wait(.5);
	$mvr_lasernodeC2_pivot.moveTo($tgt_move_here_C2);
	$mvr_lasernodeC2_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeC2_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	$mvr_lasernodeA1_pivot.moveTo($tgt_move_here_A1);
	$mvr_lasernodeA1_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeA1_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);

	sys.wait(.5);
	$mvr_lasernodeA2_pivot.moveTo($tgt_move_here_A2);
	$mvr_lasernodeA2_pivot.rotateDownTo(1, 0.1);
	$mvr_lasernodeA2_pivot.startSoundShader("process2_node_raise_rotate", SND_CHANNEL_ANY);
	
	// by the time B1 is done moving, B2 is blocking the path of the beam
	sys.waitFor($mvr_lasernodeB1_pivot); 

	


	// adjust the input beam
	$tgt_input_laser_endpoint.setOrigin($mvr_lasernodeB1_pivot.getOrigin());
	toggleEffectOnOff($fx_laser_from_door_1); //turn it off and on again very quickly so the destination updates
	sys.waitFrame();
	toggleEffectOnOff($fx_laser_from_door_1);
	toggleEffectOnOff($fx_lasernodeB1_input1);
	toggleEffectOnOff($fx_laserimpactA1_1);

	/* moved this
	// set off the iron maiden trap
	ironMaidenAttack();
	*/
	
	sys.wait(2); // wait a little longer to be sure everything is finished moving

	// bind the effects to the pivot
	initLaserPuzzle(); // the puzzle is ready to begin
	//sys.wait(3);
	
	$func_mover_12232.setKey("gui_parm_disable", "0");
	$func_mover_12232.setGuiParm( "noninteractive", "0" );; // turn on the gui to manipulate the nodes
}


// raises the node cases
void raiseNodeCases() {
	$node_case_1.move(-1, 352);
// merged all 8 to 1 ent to help batching
/*	sys.wait(.5);
	$node_case_2.move(-1, 352);
	$node_case_3.move(-1, 352);
	sys.wait(.5);
	$node_case_4.move(-1, 352);
	$node_case_5.move(-1, 352);
	sys.wait(.5);
	$node_case_6.move(-1, 352);
	$node_case_8.move(-1, 352);
	sys.wait(.5);
	$node_case_7.move(-1, 352);
	
	sys.waitFor($node_case_7);*/
	
	sys.waitFor($node_case_1);
	raise8NodePuzzle();
}

float nodeCaseOpen = 0;

// combines the opening sequence into one event
void exposeLaserNodes() 
{
	nodeCaseOpen = $node_case_1.getFloatKey("nodeCaseCheck");
		
	if (nodeCaseOpen == 0)
	{
		$node_case_1.setKey("nodeCaseCheck","1");
		openWindows();
		sys.wait(2);
		raiseNodeCases();
	}
	
	else 
	{
		sys.println("cannot move again; return negative command to gui"); // needs a GUI
	}
}



/* UNUSED
void beamInteractWithPlatform(entity entTrigger)
{
	boolean aligned = false;

	// check to see if the platform is lined up such that the beam can pass through
	vector orientation = $nodePlatTall.getAngles();
	if (orientation_z > 359 || orientation_z < 1) // if the angle is approximately 0
		aligned = true;
	else if (orientation_z < 91 && orientation_z > 89) // if the angle is approximately 90
		aligned = true;
	else if (orientation_z < 181 && orientation_z > 179) // if the angle is approximately 180
		aligned = true;
	else if (orientation_z < 271 && orientation_z > 271) // if the angle is approximately 270
		aligned = true;

	if (!aligned) // if not, play the impact effect
	{
		toggleEffectOnOff(sys.getEntity(entTrigger.getKey("impact_effect")));
		return;
	}

	// if so, start the beam on the other side of the platform and update the node it's pointing to
	toggleEffectOnOff(sys.getEntity(entTrigger.getKey("beam_effect")));
	updateNode(sys.getEntity(entTrigger.getKey("nodeToUpdate")), entTrigger);
	return;

}*/

// this is moved off to the side in the map?
/*void getSledgeOffElevator(entity elevatorTrigger)
{
	return; // FIXME:  Remove this function if everything works without it doing anything
	//sys.println("sledge is getting off the elevator!");

	// wait for the elevator to stop moving
	sys.waitFor(sys.getEntity(elevatorTrigger.getKey("elevatorName")));

	// hacky hacky
	//if (elevatorTrigger == $tgr_get_sledge_off_elevator_2) // special case this one so it plays nice with the rotating part
	//{
		// FIXME:  Turn off $func_aas_obstacle_4

	//}

	// there is a target null bound to the elevator, so it should always be on the right floor
	aiScriptedMoveWait($npc_sledge, sys.getEntity(elevatorTrigger.getKey("moveTargetName")), 32, 1);

	$npc_sledge.setLeader($player1);
}*/


void forceSledgeCatchUp(entity tgr)
{
	// If the user takes an elevator and Sledge doesn't get there in time, call this function as soon as the player is out
	// of view of the elevator.  It will teleport Sledge past the elevator so that he can catch up.

	// Make sure Sledge actually needs to be teleported

	vector sledgePos = $npc_sledge.getOrigin();
	vector destination = sys.getEntity(tgr.getKey("destination")).getOrigin(); 
	float maxZdisplacement = tgr.getFloatKey("maxZdisplacement"); // used for determining what floor should be on

	if (abs(sledgePos_z - destination_z) <= maxZdisplacement)
		return; // sledge is at roughly the same level as the floor we're on, so he probably followed the player successfully

    // Teleport him

	$npc_sledge.setOrigin(destination);
	$npc_sledge.setLeader($player1);
	

}


//--------------------------------------------------------------------------------
// void breakTeleporter()
//
// Function to turn a normal teleporter into a shot-up one.  
//
// gcarlson | Apr 2005
//--------------------------------------------------------------------------------
void breakTeleporter(entity tgr)
{
	// When the user shoots a teleporter, it should switch to the broken model and stop working
	//sys.println("breakTeleporter called");

	vector location = sys.getEntity(tgr.getKey("ball")).getOrigin();

	// play an explosion effect to hide the model swap
	sys.playWorldEffect("effects/explosions/surface/medium.fx", location, '0 0 1');

	// get rid of the not broken version
	sys.getEntity(tgr.getKey("ball")).remove();
	sys.getEntity(tgr.getKey("socket")).remove();

	// show the broken version
	sys.getEntity(tgr.getKey("broken")).show();

	// disable the teleporter 
	sys.getEntity(tgr.getKey("spawn_target")).remove(); //

	// swap out the effects
//	sys.trigger(sys.getEntity(tgr.getKey("broken_effect"))); // on	Removing broken effect per design change 6/30/05 gc
	sys.trigger(sys.getEntity(tgr.getKey("working_effect"))); // off
	
	// check for a failed teleport
	if (tgr.getFloatKey("canTeleportFail") > 0)
	{
		if (sys.randomInt(10) == 0) // 10% chance
		{
			// wait a small random delay
			sys.wait(sys.random(3));

			// spawn a strogg marine
			entity monster = sys.spawn("monster_strogg_marine");
			location = sys.getEntity(tgr.getKey("broken")).getOrigin();
			vector orientation = sys.getEntity(tgr.getKey("broken")).getAngles();
			location_z -= 176;
			orientation_y -= 90;
			monster.setOrigin(location);
			monster.setAngles(orientation);

			// animate and die
			sys.playWorldEffect("effects/monsters/teleport", location, '0 0 1');
			sys.playWorldEffect("effects/monsters/teleport_malfunction", location, '0 1 1');
			aiScriptedAnimWait(monster, "teleport_fail", 3, 1);
			monster.kill();
		}
	}
}



// Alcoves for second node puzzle area! - aweldon Feb 05

// Eventually these functions should be merged into more efficient arrangements using parameters for world entities and such.

void openEastAlcove( )	{

	raisePlatform();

	sys.wait( .5 );
	//sys.println( "Opening East Alcove" );
	
	// Move times for initial burst.
	$alcoveEast.time( .1 );
	$alcoveEast.decelTime( .1 );
	$sliderEast.bind( $alcoveEast );
		
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE_EVENTUALLY );
	
	// Burst
	$alcoveEast.move( WEST , 1 );
	sys.waitFor( $alcoveEast );
	
	// Slow down for the rest of the move
	$alcoveEast.time( .5 );
	$alcoveEast.accelTime( .5 );
	$alcoveEast.decelTime( .5 );
	$alcoveEast.move( EAST , 33 );
	
	// Play effects here
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	sys.trigger($speaker_3);
		
	sys.waitFor( $alcoveEast );
	
	//Break binds and set new times
	$sliderEast.unbind();
	$sliderEast.time( 2 );
	$sliderEast.accelTime( 1 );
	$sliderEast.decelTime( 2 ); 
		
	$alcoveEast.time( 1 );
	$alcoveEast.accelTime( 1.5 );
	$alcoveEast.decelTime( .5 );
		
	$alcoveEast_base.time( 2 );
	$alcoveEast_base.decelTime( 2 );
		
	// Move clear of top section
	$alcoveEast.move( DOWN , 64 );
	sys.wait( 1 );
	$alcoveEast_base.rotate( '8 0 0' );
	$sliderEast.move( DOWN , 224 );
	
	sys.trigger( $eastAlcoveSentry );	
	sys.waitFor( $sliderEast );
	
	// Re-bind to make stuff get out of the way properly
	$sliderEast.bind( $alcoveEast );
		
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE_EVENTUALLY );
	
	//sys.println( "East Alcove open!" );	
	
}	

void openNorthAlcove()	{

	sys.wait( .5 );

	//sys.println( "Opening North Alcove" );
	// Move times for initial burst.
	$alcoveNorth.time( .1 );
	$alcoveNorth.decelTime( .1 );
	$sliderNorth.bind( $alcoveNorth );
	
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE );
	
	// Burst
	$alcoveNorth.move( SOUTH , 1 );
	sys.waitFor( $alcoveNorth );

			
	// Slow down for the rest of the move
	$alcoveNorth.time( .5 );
	$alcoveNorth.accelTime( .5 );
	$alcoveNorth.decelTime( .5 );
	$alcoveNorth.move( NORTH , 33 );
	
	// Play effects here
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	sys.trigger($speaker_4);
	
	sys.waitFor( $alcoveNorth );
	
	//Break binds and set new times
	$sliderNorth.unbind();
	$sliderNorth.time( 2 );
	$sliderNorth.accelTime( 1 );
	$sliderNorth.decelTime( 2 ); 
		
	$alcoveNorth.time( 1 );
	$alcoveNorth.accelTime( 1.5 );
	$alcoveNorth.decelTime( .5 );
	
	$alcoveNorth_base.time( 2 );
	$alcoveNorth_base.decelTime( 2 );
	
	// Move clear of top section
	$alcoveNorth.move( DOWN , 64 );
	sys.wait( 1 );
	$alcoveNorth_base.rotate( '8 0 0' );
	$sliderNorth.move( DOWN , 224 );
	
	sys.trigger( $northAlcoveSentry );
	sys.waitFor( $sliderNorth );
	
	// Re-bind to make stuff get out of the way properly
	$sliderNorth.bind( $alcoveNorth );
	
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE_EVENTUALLY );

	//sys.println( "North Alcove open!" );	
}	

void openWestAlcove()	{

	sys.wait( .5 );

	//sys.println( "Opening West Alcove" );
	// Move times for initial burst.
	$alcoveWest.time( .1 );
	$alcoveWest.decelTime( .1 );
	$sliderWest.bind( $alcoveWest );
	
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE_EVENTUALLY );
	
	// Burst
	$alcoveWest.move( EAST , 1 );
	sys.waitFor( $alcoveWest );

			
	// Slow down for the rest of the move
	$alcoveWest.time( .5 );
	$alcoveWest.accelTime( .5 );
	$alcoveWest.decelTime( .5 );
	$alcoveWest.move( WEST , 33 );
	
	// Play effects here
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	// sys.trigger( $EFFECT_GOES_HERE_EVENTUALLY );
	sys.trigger($speaker_5);
	
	sys.waitFor( $alcoveWest );
	
	//Break binds and set new times
	$sliderWest.unbind();
	$sliderWest.time( 2 );
	$sliderWest.accelTime( 1 );
	$sliderWest.decelTime( 2 ); 
		
	$alcoveWest.time( 1 );
	$alcoveWest.accelTime( 1.5 );
	$alcoveWest.decelTime( .5 );
	
	$alcoveWest_base.time( 2 );
	$alcoveWest_base.decelTime( 2 );
	
	// Move clear of top section
	$alcoveWest.move( DOWN , 64 );
	sys.wait( 1 );
	$alcoveWest_base.rotate( '8 0 0' );
	$sliderWest.move( DOWN , 224 );
	
	sys.trigger( $westAlcoveSentry );
	sys.waitFor( $sliderWest );
	
	// Re-bind to make stuff get out of the way properly
	$sliderWest.bind( $alcoveWest );
	
	// Trigger light(s)
	//sys.trigger( $LIGHT_GOES_HERE );

	//sys.println( "West Alcove open!" );	
}

//calls elevator down near second laser puzzle -corey
void callLightTankElevator()
{
	//bring lift down
	$func_elevator_1.gotoFloor(1);
}

//teleporter lighting effects for iron maiden room near roof lift -corey
void spawnerTeleportLeft()
{
	sys.print("colour swap left");
	sys.trigger($target_setinfluence_teleport_left);
}

void spawnerTeleportRight()
{
	sys.print("colour swap right");
	sys.trigger($target_setinfluence_teleport_right);
}

void startShaftPistons()
{
	// in lift up with sledge
	$intro_pump_1.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(1);
	$intro_pump_2.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(.5);
	$intro_pump_3.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(2);
	$intro_pump_4.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(.5);
	$intro_pump_5.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(1);
	$intro_pump_6.playCycle(ANIMCHANNEL_ALL, "cycle");

	// near top of tower
	sys.wait(.5);
	$intro_pump_7.playCycle(ANIMCHANNEL_ALL, "cycle");
	sys.wait(3);
	$intro_pump_8.playCycle(ANIMCHANNEL_ALL, "cycle");
}

void startSpinnyCoupling()
{
	$level_lasercoupling_1.playCycle(ANIMCHANNEL_ALL, "spin_loop");
}

//turns outdoor lights on/off. lights outdoors are rather big and causing issues indoors -corey
float lightsAreOn = 0;

void outdoorLightsOn()
{
	if (lightsAreOn == 0)
	{
		//sys.println("light!");
		//sys.trigger($light_outdoor_1);
		sys.trigger($light_outdoor_2);
		sys.trigger($light_outdoor_3);
		sys.trigger($light_outdoor_4);
		lightsAreOn = 1;
	}
}

void outdoorLightsOff()
{
	if (lightsAreOn == 1)
	{
		//sys.println("NOOOOO light!");
		//sys.trigger($light_outdoor_1);
		sys.trigger($light_outdoor_2);
		sys.trigger($light_outdoor_3);
		sys.trigger($light_outdoor_4);
		lightsAreOn = 0;
	}
}

void init1nodePuzzle()
{
	// the effects must be bound by position (not orientation) or they will not play in the right direction
	$fx_lasernode_input_1.bindPosition( $mvr_lasernode_pivot_1);
	$fx_lasernode_input_2.bindPosition( $mvr_lasernode_pivot_1);
	$fx_lasernode_impact_1.bindPosition( $mvr_lasernode_pivot_1);
	$fx_lasernode_impact_2.bindPosition( $mvr_lasernode_pivot_1);
}

void singleNodePuzzleSolvedUnsolved()
{
	if ($door_lasernode_1.getFloatKey("locked") > 0)
	{
		//sys.println("unlock door");
		$door_lasernode_1.lock(0);
		$door_lasernode_1.setShaderParm(7,1); // green lights
		$door_frame_1_node_puzzle.setShaderParm(7,1);
		aiSpeak($npc_sledge, "lipsync_vo_3_1_14_178_1");
				
		//indicate status light
		//sys.println("green");
		$light_8525.setColor(0, 1, 0.1);
		
		//tether sledge to player
		sys.trigger($trigger_once_tethersledge);
		
		//success sound
		sys.trigger($speaker_161);
		
		//lights return to normal (only happens once)
		sys.trigger($trigger_relay_5);
	}
	else
	{
		//sys.println("lock door");
		$door_lasernode_1.lock(1);
		$door_lasernode_1.setShaderParm(7,0); // red lights
		$door_frame_1_node_puzzle.setShaderParm(7,0);
		
		//indicate status light
		//sys.println("red");
		$light_8525.setColor(1, 0.02, 0);
	}
}


void startAnimatedDecorations()
{
	// Make sure all of the people connected to machinery 
	// have their animations offset a little bit.

	$env_crucified_1.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(2);
	$env_crucified_2.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_crucified_3.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(2);
	$env_crucified_4.playCycle(ANIMCHANNEL_ALL, "idle");

	$env_dispersal_digester_6.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_4.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_10.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(3);
	$env_dispersal_digester_7.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_1.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_16.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_dispersal_digester_3.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_6.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_11.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(2);
	$env_dispersal_digester_4.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_17.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_dispersal_digester_9.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_2.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_13.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(2);
	$env_dispersal_digester_8.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_7.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_dispersal_digester_5.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_3.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_18.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_dispersal_digester2_1.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_8.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_14.playCycle(ANIMCHANNEL_ALL, "idle");
	sys.wait(1);
	$env_dispersal_digester_3.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_5.playCycle(ANIMCHANNEL_ALL, "idle");
//	$env_guiguy_15.playCycle(ANIMCHANNEL_ALL, "idle");

	$env_battery1_1.playCycle(ANIMCHANNEL_ALL, "idle");
	$env_battery_2.playCycle(ANIMCHANNEL_ALL, "idle");
	$env_battery_4.playCycle(ANIMCHANNEL_ALL, "idle");
	$env_battery_6.playCycle(ANIMCHANNEL_ALL, "idle");

}

//top of the tower sledge sees what's left of cougar squad.
void sledgeFeelsSad()
{
	aiSpeak($npc_sledge, "lipsync_vo_3_1_15_40_1");
	$npc_sledge.lookAt($target_null_cougarsquadlook);
	sys.wait(1.5);
	$npc_sledge.lookAt($null_entity);
}


//moves one flyer sprite across the sky
//------------------------------------------------------------------------------------
void maintainStroggFlyerSprite(entity entMover, entity fxNormal, entity fxDamage, entity entHangar, entity entTgrEnd, vector vDirection)
{	
	sys.wait( sys.random(10) );
	
	//will the planes be swervey?
	float fSwerve = 0;
	float fWaitTime = 0;
	float fAmplitude = 0;

	while(1)	
	{
		//place the mover on the "hangar" line, equal in the X but displaced in the Y by +/- ___ units
		// +/- Y displacement
		float fDisplacementMax = 2000;
		float fDelta = 0;

		//start location for the flyer
		vector vStart = entHangar.getWorldOrigin();
		vector vSpeed = '0 0 0';
		vector vAngs;

		//flyer speed
		float fSpeed = 900 + (sys.random(600));

		fSwerve = sys.random(200) + 100;
		fAmplitude = sys.random(90) + 30;

		//stop the flyer-- move him into position after we figure out where he goes.
		entMover.setLinearVelocity( '0 0 0');

		//mathery mcmath
		fDelta = (0 - fDisplacementMax + sys.random( fDisplacementMax * 2));
		vStart_y += fDelta;

		//move to position
		entMover.setWorldOrigin( vStart );
		sys.waitFrame();
		
		//set the direction as speed
		vSpeed = vDirection * fSpeed;	
		vSpeed_z = 0;

		// set initial angle in case this is a non-swerving dude..
		vAngs = sys.VecToAngles(vSpeed);
		entMover.setAngles(vAngs);
	
		fWaitTime = sys.getTime() +  sys.random(2.5);
	
		//turn on the regular plane, turn off the alternate
		fxNormal.start();
		fxDamage.stop();	
		
		while( sys.getTime() < fWaitTime)	
		{
			//fly!
			entMover.setLinearVelocity( vSpeed);

			//swerve if need be
			if( fSwerve != 0)	
			{
				vSpeed_y = sys.sin( sys.getTime() * fAmplitude ) *  fSwerve;

				// update facing so effects can draw properly
				vAngs = sys.VecToAngles(vSpeed);
				entMover.setAngles(vAngs);
			}

			//if somehow the ship has escaped the skybox, break
			if( entMover.touches( entTgrEnd))	
			{
				break;
			}
			//decend on the way out
			sys.waitFrame();
		}

		//second loop, descend.
		vSpeed_z = 0;

		if(sys.random(20) < 2)
		{
			//sys.println("Damaged!");

			//slow down and fly off course, descend faster
			vSpeed_x *= 0.25;
			if (vSpeed_y < 10 && vSpeed_y > -10)	
			{
				vSpeed_y += ( -800 + sys.random(1600));
			} else	
			{
				vSpeed_y *= 4;
			}
			vSpeed_z *= 1.25;

			//no more swerving
			fSwerve = 0;

			//switch to damaged effect, and explode
			fxNormal.stop();
			fxDamage.start();
			$fx_flyer_damage.setWorldOrigin( entMover.getWorldOrigin() );
			sys.trigger( $fx_flyer_damage);
		}
		
		fWaitTime = sys.getTime() +  5;

		//after the possible damage time, remove once the ship has left the skybox
		while( (sys.getTime() < fWaitTime) && ( !entMover.touches( entTgrEnd))  )	
		{
			//fly!
			entMover.setLinearVelocity( vSpeed);

			//swerve if need be
			if( fSwerve != 0)	
			{
				vSpeed_y = sys.sin( sys.getTime() * fAmplitude ) *  fSwerve;
				// update facing so effects can draw properly
				vAngs = sys.VecToAngles(vSpeed);
				entMover.setAngles(vAngs);
			}

			//decend on the way out
			sys.waitFrame();
		}
	}
}

//shaft beam pulse
void beamPulse()
{
	while(1)
	{
		sys.trigger($beamBlastLight);
		$beamBlastFlare.show();
		setNewTimes($beamBlast, 3 , 0 , 0 );
		$beamBlast.moveTo($target_null_beamBlastBottom);
		sys.waitFor($beamBlast);

		//return
		sys.trigger($beamBlastFx);	// off		
		$beamBlastFlare.hide();		
		sys.trigger($beamBlastLight);
		setNewTimes($beamBlast, .1 , 0 , 0 );
		$beamBlast.moveTo($target_null_beamBlastTop);
		sys.waitFor($beamBlast);
		sys.wait(1);
		sys.trigger($beamBlastFx);	// on
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////Additions by Chad////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void stop_sledge()
{
	$sledge_stopper.show();
}

void sledge_death()
{
	sys.trigger($sledge_died);
}

void enable_lift_1()
{
	$npc_sledge.setKey( "allowPlayerPush", "0" );
	$func_elevator_29.setKey("gui_parm_disable", "0");
	$func_elevator_29.setGuiParm( "noninteractive", "0" );
}

void enable_lift_2()
{
	$npc_sledge.setKey( "allowPlayerPush", "0" );
	$func_elevator_34.setKey("gui_parm_disable", "0");
	$func_elevator_34.setGuiParm( "noninteractive", "0" );
}

void enable_lift_3()
{
	$func_static_54062.setKey("gui_parm_disable", "0");
	$func_static_54062.setGuiParm( "noninteractive", "0" );
}

void sledge_push()
{
	$npc_sledge.setKey( "allowPlayerPush", "1" );
}

void nopush_sledge()
{
	$npc_sledge.setKey( "allowPlayerPush", "0" );
}

void exit_elevator_enable()
{
	$func_elevator_29.setKey("gui_parm_disable", "0");
	$func_elevator_29.setGuiParm( "noninteractive", "0" );
}

void func_elevator_3_enable()
{
	$func_elevator_3_gui.setKey("gui_parm_disable", "0");
	$func_elevator_3_gui.setGuiParm( "noninteractive", "0" );
}

void main()
{	
	thread lowerPlatform( );
	
	$func_static_54317.setGuiParm( "noninteractive", "1" );
	$func_mover_12232.setGuiParm( "noninteractive", "1" );
	$func_elevator_29.setGuiParm( "noninteractive", "1" );
	$func_elevator_34.setGuiParm( "noninteractive", "1" );
	$func_static_54062.setGuiParm( "noninteractive", "1" );
	$func_elevator_3_gui.setGuiParm( "noninteractive", "1" );

	//strogg vs marine airpower go!
	//float t;
	
	//originally, there were six planes per side. Now we're using 2, and that might change too. But the
	//+6 for the 3rd parameter is because originally the damaged versions of the sprites started at 7.
	//for (t = 1; t <= 2; t++)	
	//{
		//thread maintainStroggFlyerSprite( sys.getEntity("mvr_fx_strogg_flyer_" + t), sys.getEntity("fx_air_strogg_fighter_" + t), sys.getEntity("fx_air_strogg_fighter_" + (t + 6) ), $tgt_strogg_flyer_hangar, $tgr_strogg_flyer_end, '-1 0 .1' );
		//thread maintainStroggFlyerSprite( sys.getEntity("mvr_fx_marine_flyer_" + t), sys.getEntity("fx_air_marine_fighter_" + t), sys.getEntity("fx_air_marine_fighter_" + (t + 6) ), $tgt_marine_flyer_hangar, $tgr_marine_flyer_end, '1 0 .1' );
	//}

	thread beamPulse();

	thread init1nodePuzzle();
	thread beamSetup();
	//thread iris_setup();
	//thread brain_setup();
	thread levelIntro();
	//thread init20nodes();
	thread startSpinnyCoupling();

	// make sure the laser puzzle sounds are loaded
	$mvr_lasernodeA1_pivot.cacheSoundShader("process2_node_raise_rotate");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process_node_movement");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process_laser_connect");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process_laser_disconnect");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process2_node_platform_start");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process2_node_platform_loop");
	$mvr_lasernodeA1_pivot.cacheSoundShader("process2_node_platform_end");

	//g_currentNode = $mvr_node_pivot_A2_top; This puzzle has been removed
	
	//make sure locked doors have red lights
	$door_lasernode_1.setShaderParm(7,0);
	$door_frame_1_node_puzzle.setShaderParm(7,0);
	$door_typical_131.setShaderParm(7,0);
	$door_frame_8_node_puzzle.setShaderParm(7,0);
	$door_typical_133.setShaderParm(7,0);
	$door_frame_20_node_puzzle.setShaderParm(7,0);
	$door_intro_east.setShaderParm(7,0);
	$frame_intro_east.setShaderParm(7,0);

	// the roof door is unlocked and should have green lights
	$door_roof.setShaderParm(7,1);
	$frame_roof_door_outside.setShaderParm(7,1);
	$frame_roof_door_inside.setShaderParm(7,1); 
	
	// Move maiden casket in first node puzzle into position
	thread prepareMaidenCasket();

	thread startAnimatedDecorations();

	//thread spinThatStuff();
/*	thread map_process2_comm_core::comCoreHover( $tgt_com_core_float_2, $tgt_com_core_float_1);

	thread map_process2_comm_core::comCoreElectricity( $fx_com_core_1, $lgt_com_core_1 );
	thread map_process2_comm_core::comCoreElectricity( $fx_com_core_2, $lgt_com_core_2 );
	thread map_process2_comm_core::comCoreElectricity( $fx_com_core_3, $lgt_com_core_3 );
	thread map_process2_comm_core::comCoreElectricity( $fx_com_core_4, $lgt_com_core_4 );
	thread map_process2_comm_core::comCoreArc(1);

	//the horseshoe room
	thread map_process2_horseshoe::maintainTorsovator("left");
	thread map_process2_horseshoe::maintainTorsovator("right"); 
	UNUSED */
	
	//HACK
	//thread manageHorseshoeLasernode(0,0);

// jshepard: where did all of this stuff go? Does any of it work?
/*
	thread dataCompressionLower();
	thread dataAnalysis1();
	thread dclCorridorMachine1(); // Data Compression Left, first corridor machine
	thread dclCorridorMachine2(); // Data Compression Left, second corridor machine
*/
////////////Binding all the clips to the casket doors/////////////////////////////
	$im_door_1.bindToJoint($env_wall_casket_9, "r_breast_plate", 0);
	$im_door_2.bindToJoint($env_wall_casket_9, "l_breast_plate", 0);
	
	$im_door_3.bindToJoint($env_wall_casket_noderoom_2, "r_breast_plate", 0);
	$im_door_4.bindToJoint($env_wall_casket_noderoom_2, "l_breast_plate", 0);
	
	$im_door_5.bindToJoint($env_wall_casket_noderoom_1, "r_breast_plate", 0);
	$im_door_6.bindToJoint($env_wall_casket_noderoom_1, "l_breast_plate", 0);
	
	$im_door_7.bindToJoint($env_wall_casket_7, "r_breast_plate", 0);
	$im_door_8.bindToJoint($env_wall_casket_7, "l_breast_plate", 0);
	
	$im_door_9.bindToJoint($env_wall_casket_8, "r_breast_plate", 0);
	$im_door_10.bindToJoint($env_wall_casket_8, "l_breast_plate", 0);
}


} // namespace map_process2